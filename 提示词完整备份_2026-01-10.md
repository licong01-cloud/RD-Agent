# RDAgent æç¤ºè¯å®Œæ•´å¤‡ä»½

**å¤‡ä»½æ—¥æœŸ**: 2026-01-10
**æ–‡ä»¶è·¯å¾„**: `rdagent/scenarios/qlib/experiment/prompts.yaml`
**å¤‡ä»½ç›®çš„**: åœ¨è¿›è¡Œæç¤ºè¯ä¼˜åŒ–å‰ï¼Œå®Œæ•´å¤‡ä»½ç°æœ‰å†…å®¹ï¼Œæ¯æ®µæ ‡æ³¨å¼•ç”¨æº

---

## æç¤ºè¯æ¸…å•

| æç¤ºè¯é”®å | è¡Œå·èŒƒå›´ | ä½¿ç”¨é˜¶æ®µ | å¼•ç”¨æº |
|-----------|---------|---------|--------|
| `qlib_quant_background` | 8-17 | é€šç”¨èƒŒæ™¯ | `prompts.yaml:8-17` |
| `qlib_factor_background` | 19-40 | å› å­èƒŒæ™¯ | `prompts.yaml:19-40` |
| `qlib_factor_interface` | 42-51 | å› å­ç¼–ç  | æ¨¡å—åŒ–å¼•ç”¨5ä¸ªæ–‡ä»¶ |
| `qlib_factor_strategy` | 53-92 | å› å­ç¼–ç  | `prompts.yaml:53-92` |
| `qlib_factor_output_format` | 94-114 | å› å­ç¼–ç  | `prompts.yaml:94-114` |
| `qlib_factor_simulator` | 116-123 | å› å­ç¼–ç  | `prompts.yaml:116-123` |
| `qlib_factor_rich_style_description` | 125-144 | UIå±•ç¤º | `prompts.yaml:125-144` |
| `qlib_factor_from_report_rich_style_description` | 146-178 | UIå±•ç¤º | `prompts.yaml:146-178` |
| `qlib_factor_experiment_setting` | 180-219 | å› å­ç¼–ç  | `prompts.yaml:180-219` |
| `qlib_model_background` | 221-237 | æ¨¡å‹èƒŒæ™¯ | `prompts.yaml:221-237` |
| `qlib_model_interface` | 239-271 | æ¨¡å‹ç¼–ç  | `prompts.yaml:239-271` |
| `qlib_model_output_format` | 274-277 | æ¨¡å‹ç¼–ç  | `prompts.yaml:274-277` |
| `qlib_model_simulator` | 279-287 | æ¨¡å‹ç¼–ç  | `prompts.yaml:279-287` |
| `qlib_model_rich_style_description` | 289-308 | UIå±•ç¤º | `prompts.yaml:289-308` |
| `qlib_model_experiment_setting` | 310-317 | æ¨¡å‹ç¼–ç  | `prompts.yaml:310-317` |
| `transformer_volume_price_strategy` | 319-332 | ç¤ºä¾‹ç­–ç•¥ | `prompts.yaml:319-332` |

---

## è¯¦ç»†å†…å®¹å¤‡ä»½

### 1. qlib_quant_background

**å¼•ç”¨æº**: `prompts.yaml:8-17`
**ä½¿ç”¨é˜¶æ®µ**: é€šç”¨èƒŒæ™¯
**é—®é¢˜**: æ— 

```yaml
qlib_quant_background: |-
  Quantitative investment is a data-driven approach to asset management that relies on mathematical models, statistical techniques, and computational methods to analyze financial markets and make investment decisions. Two essential components of this approach are factors and models.

  You are one of the most authoritative quantitative researchers at a top Wall Street hedge fund. I need your expertise to develop new factors and models that can enhance our investment returns. Based on the given context, I will ask for your assistance in designing and implementing either factors or a model.

  {% if runtime_environment is not none %}
  ====== Runtime Environment ======
  You have following environment to run the code:
  {{ runtime_environment }}
  {% endif %}
```

---

### 2. qlib_factor_background

**å¼•ç”¨æº**: `prompts.yaml:19-40`
**ä½¿ç”¨é˜¶æ®µ**: å› å­èƒŒæ™¯
**é—®é¢˜**: æ— 

```yaml
qlib_factor_background: |-
  The factor is a characteristic or variable used in quant investment that can help explain the returns and risks of a portfolio or a single asset. Factors are used by investors to identify and exploit sources of excess returns, and they are central to many quantitative investment strategies.
  Each number in the factor represents a physics value to an instrument on a day.
  User will train a model to predict the next several days return based on the factor values of the previous days.
  The factor is defined in the following parts:
  1. Name: The name of the factor.
  2. Description: The description of the factor.
  3. Formulation: The formulation of the factor.
  4. Variables: The variables or functions used in the formulation of the factor.
  The factor might not provide all the parts of the information above since some might not be applicable.
  Please specifically give all the hyperparameter in the factors like the window size, look back period, and so on. One factor should statically defines one output with a static source data. For example, last 10 days momentum and last 20 days momentum should be two different factors.

  å¯¹äºæ¯ä¸€ä¸ªå› å­ï¼Œè¯·ç”¨ã€Œç®€ä½“ä¸­æ–‡ã€ç»™å‡ºæ¸…æ™°çš„åŸºç¡€è§£é‡Šï¼ŒåŒ…æ‹¬ï¼š
  - å› å­åç§°ï¼ˆå¯ä»¥ä¸­è‹±ç»“åˆï¼Œä¾‹å¦‚ï¼š10 æ—¥åŠ¨é‡ï¼ˆMomentum_10Dï¼‰ï¼‰ï¼›
  - å› å­çš„ç›´è§‚å«ä¹‰ï¼ˆå®ƒæƒ³åˆ»ç”»ä»€ä¹ˆé‡‘èç‰¹æ€§ï¼Œä¾‹å¦‚åŠ¨é‡ã€æ³¢åŠ¨ç‡ã€æµåŠ¨æ€§ç­‰ï¼‰ï¼›
  - å…³é”®è¶…å‚æ•°ï¼ˆå¦‚çª—å£é•¿åº¦ã€å›çœ‹æœŸï¼‰ï¼Œä»¥åŠè¿™äº›è¶…å‚æ•°å¯¹å› å­è¡Œä¸ºçš„å½±å“ã€‚

  {% if runtime_environment is not none %}
  ====== Runtime Environment ======
  You have following environment to run the code:
  {{ runtime_environment }}
  {% endif %}
```

---

### 3. qlib_factor_interface

**å¼•ç”¨æº**: `prompts.yaml:42-51`ï¼ˆæ¨¡å—åŒ–å¼•ç”¨ï¼‰
**ä½¿ç”¨é˜¶æ®µ**: å› å­ç¼–ç 
**é—®é¢˜**: å·²ä¼˜åŒ–ï¼ˆ2026-01-09 æ‹†åˆ†ä¸º5ä¸ªæ¨¡å—ï¼‰

```yaml
qlib_factor_interface: |-
  {% include "scenarios.qlib.experiment.prompts_core_constraints:qlib_factor_interface_core_constraints" %}

  {% include "scenarios.qlib.experiment.prompts_data_loading:qlib_factor_interface_data_loading" %}

  {% include "scenarios.qlib.experiment.prompts_error_prevention:qlib_factor_interface_error_prevention" %}

  {% include "scenarios.qlib.experiment.prompts_dataset_info:qlib_factor_interface_dataset_info" %}

  {% include "scenarios.qlib.experiment.prompts_language_spec:qlib_factor_interface_language_spec" %}
```

**æ¨¡å—æ–‡ä»¶å†…å®¹**:
- `prompts_core_constraints.yaml` - æ ¸å¿ƒçº¦æŸï¼ˆç»Ÿä¸€æ¨¡æ¿ã€è¾“å‡ºæ ¼å¼ï¼‰
- `prompts_data_loading.yaml` - æ•°æ®åŠ è½½è§„èŒƒ
- `prompts_error_prevention.yaml` - é”™è¯¯é¢„é˜²
- `prompts_dataset_info.yaml` - æ•°æ®é›†ä¿¡æ¯
- `prompts_language_spec.yaml` - è¯­è¨€è§„èŒƒ

---

### 4. qlib_factor_strategy

**å¼•ç”¨æº**: `prompts.yaml:53-92`
**ä½¿ç”¨é˜¶æ®µ**: å› å­ç¼–ç 
**é—®é¢˜**: ğŸ”´ **P0** - ç¬¬65-70è¡Œå±•ç¤º `reset_index()` ç¤ºä¾‹ï¼Œä¸æ ¸å¿ƒçº¦æŸå†²çª

```yaml
qlib_factor_strategy: |-
  Ensure that for every step of data processing, the data format (including indexes) is clearly explained through comments.
  Each transformation or calculation should be accompanied by a detailed description of how the data is structured, especially focusing on key aspects like whether the data has multi-level indexing, how to access specific columns or index levels, and any operations that affect the data shape (e.g., `reset_index()`, `groupby()`, `merge()`).
  This step-by-step explanation will ensure clarity and accuracy in data handling. For example:
  Note: The examples below are for explanation only. In this project, you should preserve the MultiIndex(`datetime`, `instrument`) contract and avoid index-changing operations unless explicitly required.
  1. **Start with multi-level index**:
    ```python
    # The initial DataFrame has a multi-level index with 'datetime' and 'instrument'.
    # To access the 'datetime' index, use df.index.get_level_values('datetime').
    datetime_values = df.index.get_level_values('datetime')
    ```

  2. **Reset the index if necessary**:
    ```python
    # Resetting the index to move 'datetime' and 'instrument' from the index to columns.
    # This operation flattens the multi-index structure.
    df = df.reset_index()
    ```

  3. **Perform groupby operations**:
    ```python
    # Grouping by 'datetime' and 'instrument' to aggregate the data.
    # After groupby, the result will maintain 'datetime' and 'instrument' as a multi-level index.
    df_grouped = df.groupby(['datetime', 'instrument']).sum()
    ```

  4. **Ensure consistent datetime formats**:
    ```python
    # Before merging, ensure that the 'datetime' column in both DataFrames is of the same format.
    # Convert to datetime format if necessary.
    df['datetime'] = pd.to_datetime(df['datetime'])
    other_df['datetime'] = pd.to_datetime(other_df['datetime'])
    ```

  5. **Merge operations**:
    ```python
    # When merging DataFrames, ensure you are merging on both 'datetime' and 'instrument'.
    # If these are part of the index, reset the index before merging.
    merged_df = pd.merge(df, other_df, on=['datetime', 'instrument'], how='inner')
    ```
```

**é—®é¢˜åˆ†æ**:
- ç¬¬65-70è¡Œï¼š`df = df.reset_index()` ç¤ºä¾‹æ²¡æœ‰è¯´æ˜å¦‚ä½•æ¢å¤ç´¢å¼•
- ä¸ `prompts_error_prevention.yaml` ä¸­"ä¸¥ç¦ä½¿ç”¨ reset_index"çš„çº¦æŸå†²çª
- LLM å¯èƒ½æ¨¡ä»¿ç¤ºä¾‹ä»£ç ï¼Œå¯¼è‡´ç´¢å¼•ç»“æ„é”™è¯¯

---

### 5. qlib_factor_output_format

**å¼•ç”¨æº**: `prompts.yaml:94-114`
**ä½¿ç”¨é˜¶æ®µ**: å› å­ç¼–ç 
**é—®é¢˜**: æ— 

```yaml
qlib_factor_output_format: |-
  Your output should be a pandas dataframe similar to the following example information:
  <class 'pandas.core.frame.DataFrame'>
  MultiIndex: 40914 entries, (Timestamp('2020-01-02 00:00:00'), '000001.SZ') to (Timestamp('2021-12-31 00:00:00'), '000750.SZ')
  Data columns (total 1 columns):
  #   Column            Non-Null Count  Dtype
  ---  ------            --------------  -----
  0   your factor name  40914 non-null  float32
  dtypes: float32(1)
  memory usage: <ignore>
  Notice: The non-null count is OK to be different to the total number of entries since some instruments may not have the factor value on some days.
  One possible format of `result.h5` may be like following:
  datetime    instrument
  2020-01-02  000001.SZ     -0.001796
              000166.SZ      0.005780
              600686.SH      0.004228
              600712.SH      0.001298
              600728.SH      0.005330
                              ...
  2021-12-31  000750.SZ      0.000000
              000776.SZ      0.002459
```

---

### 6. qlib_factor_simulator

**å¼•ç”¨æº**: `prompts.yaml:116-123`
**ä½¿ç”¨é˜¶æ®µ**: å› å­ç¼–ç 
**é—®é¢˜**: ğŸŸ¡ **P1** - èƒŒæ™¯ä»‹ç»å†—ä½™ï¼ˆQlibå¹³å°ä»‹ç»ã€å·¥ä½œæµç¨‹è¯´æ˜ï¼‰

```yaml
qlib_factor_simulator: |-
  The factors will be sent into Qlib to train a model to predict the next several days return based on the factor values of the previous days.
  Qlib is an AI-oriented quantitative investment platform that aims to realize the potential, empower research, and create value using AI technologies in quantitative investment, from exploring ideas to implementing productions. Qlib supports diverse machine learning modeling paradigms. including supervised learning, market dynamics modeling, and RL.
  User will use Qlib to automatically do the following things:
  1. generate a new factor table based on the factor values.
  2. train a model like LightGBM, CatBoost, LSTM or simple PyTorch model to predict the next several days return based on the factor values.
  3. build a portfolio based on the predicted return based on a strategy.
  4. evaluate the portfolio's performance including the return, sharpe ratio, max drawdown, and so on.
```

**é—®é¢˜åˆ†æ**:
- ç¬¬117-118è¡Œï¼šQlib å¹³å°èƒŒæ™¯ä»‹ç»
- ç¬¬119-123è¡Œï¼šRDAgent å·¥ä½œæµç¨‹è¯´æ˜
- ä¸å› å­ç¼–ç çš„æ ¸å¿ƒä»»åŠ¡ï¼ˆè®¡ç®—å› å­å€¼ï¼‰æ— å…³

---

### 7. qlib_factor_rich_style_description

**å¼•ç”¨æº**: `prompts.yaml:125-144`
**ä½¿ç”¨é˜¶æ®µ**: UIå±•ç¤ºï¼ˆStreamlitï¼‰
**é—®é¢˜**: ğŸŸ¡ **P1** - å› å­ç¼–ç é˜¶æ®µä¸éœ€è¦

```yaml
qlib_factor_rich_style_description : |-
  ### R&D Agent-Qlib: Automated Quantitative Trading & Iterative Factors Evolution Demo

  #### [Overview](#_summary)

  The demo showcases the iterative process of hypothesis generation, knowledge construction, and decision-making. It highlights how financial factors evolve through continuous feedback and refinement.

  #### [Automated R&D](#_rdloops)

  - **[R (Research)](#_research)**
    - Iterative development of ideas and hypotheses.
    - Continuous learning and knowledge construction.

  - **[D (Development)](#_development)**
    - Progressive implementation and code generation of factors.
    - Automated testing and validation of financial factors.

  #### [Objective](#_summary)

  To demonstrate the dynamic evolution of financial factors through the Qlib platform, emphasizing how each iteration enhances the accuracy and reliability of the resulting financial factors.
```

**ä½¿ç”¨ä½ç½®**:
- `log/ui/app.py:907` - `st.markdown(state.scenario.rich_style_description + css, unsafe_allow_html=True)`
- `scenarios/qlib/experiment/factor_experiment.py:38` - åœºæ™¯ç±»åˆå§‹åŒ–

**å½±å“**:
- åˆ é™¤ä¼šå½±å“ UI å±•ç¤º
- ä¸å½±å“å› å­ç¼–ç ï¼ˆLLM ä¸ä½¿ç”¨ï¼‰

---

### 8. qlib_factor_from_report_rich_style_description

**å¼•ç”¨æº**: `prompts.yaml:146-178`
**ä½¿ç”¨é˜¶æ®µ**: UIå±•ç¤ºï¼ˆStreamlitï¼‰
**é—®é¢˜**: ğŸŸ¡ **P1** - å› å­ç¼–ç é˜¶æ®µä¸éœ€è¦

```yaml
qlib_factor_from_report_rich_style_description : |-
  ### R&D Agent-Qlib: Automated Quantitative Trading & Factor Extraction from Financial Reports Demo

  #### [Overview](#_summary)

  This demo showcases the process of extracting factors from financial research reports, implementing these factors, and analyzing their performance through Qlib backtest, continually expanding and refining the factor library.

  #### [Automated R&D](#_rdloops)

  - **[R (Research)](#_research)**
    - Iterative development of ideas and hypotheses from financial reports.
    - Continuous learning and knowledge construction.

  - **[D (Development)](#_development)**
    - Progressive factor extraction and code generation.
    - Automated implementation and testing of financial factors.

  #### [Objective](#_summary)

  <table border="1" style="width:100%; border-collapse: collapse;">
    <tr>
      <td>ğŸ’¡ <strong>Innovation </strong></td>
      <td>Tool to quickly extract and test factors from research reports.</td>
    </tr>
    <tr>
      <td>âš¡ <strong>Efficiency </strong></td>
      <td>Rapid identification of valuable factors from numerous reports.</td>
    </tr>
    <tr>
      <td>ğŸ—ƒï¸ <strong>Outputs </strong></td>
      <td>Expand and refine the factor library to support further research.</td>
    </tr>
  </table>
```

**ä½¿ç”¨ä½ç½®**:
- `scenarios/qlib/experiment/factor_from_report_experiment.py:10` - åœºæ™¯ç±»åˆå§‹åŒ–

---

### 9. qlib_factor_experiment_setting

**å¼•ç”¨æº**: `prompts.yaml:180-219`
**ä½¿ç”¨é˜¶æ®µ**: å› å­ç¼–ç 
**é—®é¢˜**: ğŸ”´ **P0** - åŒ…å«å¤§é‡ä¸å› å­ç¼–ç æ— å…³çš„å†…å®¹

```yaml
qlib_factor_experiment_setting: |-
  | Dataset ğŸ“Š | Model ğŸ¤–    | Factors ğŸŒŸ       | Data Split  ğŸ§®                                   |
  |---------|----------|---------------|-------------------------------------------------|
  | AIstock A-share (non-ST, non-delisted)  | GRU_TimeSeries_Model | Alpha158 Plus + AIstock factors | Train: 2010-01-07 to 2018-12-31 <br> Valid: 2019-01-01 to 2020-12-31 <br> Test &nbsp;: 2021-01-01 to 2025-12-01 |

  **é‡è¦è¯´æ˜ï¼šè‚¡ç¥¨ä»£ç æ ¼å¼**
  - è™½ç„¶æ•°æ®é›†åç§°ä¸º "AIstock A-share"ï¼Œä½†æ‰€æœ‰åŸå§‹ HDF5/Parquet æ•°æ®ä¸­çš„ `instrument` å‡å·²ç»Ÿä¸€ä¸º **Qlib é£æ ¼**ï¼ˆå¦‚ `000001.SZ`, `600000.SH`ï¼‰ã€‚
  - **ç¦æ­¢**åœ¨å› å­è„šæœ¬ä¸­è¿›è¡Œä»»ä½•å½¢å¼çš„æ ¼å¼è½¬æ¢é€»è¾‘.

  #### è®¡ç®—èµ„æºä¸è®­ç»ƒè´Ÿè½½å»ºè®®ï¼ˆè¯·ä¼˜å…ˆæ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼Œä»¥å……åˆ†åˆ©ç”¨æœ¬æœº 12 æ ¸ 24 çº¿ç¨‹ + GPUï¼‰
  - **è®­ç»ƒè½®æ•°ä¸ batch å¤§å°**ï¼š
    - å¯¹äºä¸»è¦å®éªŒï¼Œè¯·é¿å…ä½¿ç”¨è¿‡å°é…ç½®ï¼ˆå¦‚ `n_epochs < 100`ã€`batch_size < 256`ï¼‰ã€‚
    - æ¨èé…ç½®èŒƒå›´ï¼š`n_epochs` åœ¨ `200~300`ï¼›`batch_size` ä»¥ `512` ä¸ºä¼˜å…ˆï¼ˆå¦‚æ˜¾å­˜ä¸è¶³å¯é™åˆ° `256`ï¼‰ã€‚
  - **å¹¶è¡Œåº¦è®¾ç½®ï¼ˆCPUï¼‰**ï¼š
    - å¯¹æ”¯æŒ `n_jobs` çš„æ¨¡å‹æˆ–æ•°æ®å¤„ç†ç»„ä»¶ï¼Œä¼˜å…ˆè®¾ç½®ä¸º `n_jobs: 12`ï¼ˆæ¥è¿‘ç‰©ç†æ ¸å¿ƒæ•°ï¼‰ã€‚
    - å¦‚ YAML ä¸­å­˜åœ¨ `workers` / `num_workers` / `processes` ç­‰å­—æ®µï¼Œå¯è®¾ç½®åœ¨ `8~12` ä¹‹é—´ï¼Œé¿å…è¿œé«˜äº CPU æ ¸å¿ƒæ•°ã€‚
  - **GPU ä½¿ç”¨**ï¼š
    - å¯¹åŸºäº PyTorch çš„æ—¶åºæ¨¡å‹ï¼ˆå¦‚ `GRU_TimeSeries_Model`ï¼‰ï¼Œå¿…é¡»ä¿è¯ `use_GPU: True`ï¼Œ`device: "cuda:0"`ï¼Œç¦æ­¢éšæ„æ”¹æˆ `cpu`ã€‚
  - **é“¾è·¯ç¨³å®šä¼˜å…ˆ**ï¼š
    - åœ¨åŠ å¤§è®­ç»ƒè´Ÿè½½å‰ï¼Œå…ˆç”¨è¾ƒå°å¾ªç¯ï¼ˆå¦‚ `--loop-n 1`ï¼‰ç¡®è®¤æ•´æ¡å› å­ä¸ Qlib è®­ç»ƒé“¾è·¯å®Œå…¨æ‰“é€šï¼š
      - ä½¿ç”¨ snapshot ä¸­å®é™…å­˜åœ¨ä¸”å¯ç”¨çš„è‚¡ç¥¨æ± ï¼ˆé€šå¸¸ä¸º `instruments: all`ï¼‰ã€‚
      - æ‰€æœ‰å› å­èƒ½åœ¨ `daily_pv.h5` ä¸ŠæˆåŠŸè®¡ç®—å¹¶ç”Ÿæˆ `result.h5`ã€‚
  - åªæœ‰åœ¨æ•´æ¡æµæ°´çº¿ä¸å†å‡ºç° `$close` / è‚¡ç¥¨æ± ä¸å­˜åœ¨ç­‰åŸºç¡€æŠ¥é”™åï¼Œæ‰é€æ­¥å¢åŠ  `n_epochs`ã€`batch_size` ä¸å¹¶è¡Œåº¦ã€‚

  #### è‚¡ç¥¨æ± ç­›é€‰ä¸æ¯æ—¥æŒ‡æ ‡å› å­çš„ä¼˜å…ˆä½¿ç”¨åŸåˆ™
  - åœ¨å› å­ä¸ç­–ç•¥æ¼”è¿›è¿‡ç¨‹ä¸­ï¼Œ**ä¼˜å…ˆä½¿ç”¨é¢„è®¡ç®—çš„ daily_basic å› å­è¡¨ï¼ˆä¼°å€¼ã€å¸‚å€¼ã€æµåŠ¨æ€§ç­‰ï¼‰åšç¨³å¥åŒ–ä¸é£é™©æ§åˆ¶**ï¼Œå†åœ¨ç›¸å¯¹"å¯äº¤æ˜“/å¯è§£é‡Š"çš„æ ·æœ¬ä¸Šè¿›è¡Œå¤šå› å­å»ºæ¨¡ä¸é€‰è‚¡ï¼š
    - ä¼˜å…ˆç”¨äºï¼šæš´éœ²æ§åˆ¶ï¼ˆè§„æ¨¡/æµåŠ¨æ€§ï¼‰ã€winsorize/clipã€åˆ†å±‚/åˆ†ç»„ä¸­æ€§åŒ–ã€ä»¥åŠå¯¹æç«¯å°¾éƒ¨æ ·æœ¬çš„æƒ©ç½šï¼ˆè¿‡æ»¤åº”ä½œä¸ºæœ€åæ‰‹æ®µï¼‰ï¼›
    - åœ¨åŠ å…¥æ–°å› å­å‰ï¼Œå…ˆç¡®ä¿åŸºç¡€å› å­é›†åœ¨ IC ä¸å›æµ‹ç¨³å®šæ€§ä¸Šä¸å†å‡ºç°ç³»ç»Ÿæ€§å´©åï¼ˆä¾‹å¦‚å…¨ NaN æˆ–æ˜¾è‘—è´Ÿæ”¶ç›Šï¼‰ã€‚

  #### ç­–ç•¥æ¼”è¿›ä¼˜å…ˆçº§ï¼ˆå½“ IC è¿ç»­ä¸º NaN æˆ–æ”¶ç›Šæ˜¾è‘—ä¸ºè´Ÿæ—¶ï¼‰
  - è‹¥æœ€è¿‘è‹¥å¹²è½®å®éªŒä¸­ï¼Œ**æ¨ªæˆªé¢ IC å¤§å¤šä¸º NaN/æ¥è¿‘ 0ï¼Œä¸”ç»„åˆå¹´åŒ–æ”¶ç›Šæ˜æ˜¾ä¸ºè´Ÿã€æœ€å¤§å›æ’¤è¿‡å¤§**ï¼Œè¯·ä¼˜å…ˆæ’æŸ¥å¹¶æ¼”è¿›ä»¥ä¸‹æ–¹å‘ï¼Œè€Œä¸æ˜¯ç›²ç›®æ›´æ¢æ›´å¤æ‚çš„æ—¶é—´åºåˆ—ç»“æ„ï¼š
    1. **å…ˆä¿®å› å­ä¸æ ‡ç­¾ï¼ˆä¿¡å·è´¨é‡ä¼˜å…ˆï¼‰**ï¼š
       - æ£€æŸ¥å› å­æ˜¯å¦è¿‘ä¼¼å¸¸æ•°ã€æ˜¯å¦è¿‡åº¦ç¨€ç–ã€æ˜¯å¦å› å¯¹é½/merge/dropna å¯¼è‡´æœ‰æ•ˆæ ·æœ¬å´©å¡Œï¼›
       - æ£€æŸ¥å¹¶ä¼˜åŒ–æ ‡ç­¾ï¼šåˆç†é€‰æ‹©é¢„æµ‹çª—å£ï¼ˆä¾‹å¦‚ 1D/5D/10D æ”¶ç›Šï¼‰ï¼Œå¹¶æ˜ç¡®æ˜¯ç»å¯¹æ”¶ç›Šè¿˜æ˜¯è¶…é¢æ”¶ç›Šï¼Œç¡®ä¿è¯„ä¼°æŒ‡æ ‡ä¸æ ‡ç­¾å£å¾„ä¸€è‡´ã€‚
    2. **ç”¨åŸºç¡€å› å­åšç¨³å¥åŒ–ä¸é£é™©ç”¨é€”**ï¼š
       - `daily_basic`ï¼ˆä¼°å€¼/å¸‚å€¼/æµåŠ¨æ€§ï¼‰ä¼˜å…ˆç”¨äºæš´éœ²æ§åˆ¶ä¸ç¨³å®šæ€§çº¦æŸï¼ˆå¿…è¦æ—¶æ‰åšè¿‡æ»¤ï¼‰ï¼›
       - `ae_recon_error_10d` æ›´é€‚åˆä½œä¸ºå¼‚å¸¸æ£€æµ‹/é£é™©å› å­å‚ä¸æƒ©ç½šæˆ–è¿‡æ»¤ï¼Œè€Œä¸æ˜¯å•ç‹¬æ‰¿æ‹…ä¸»è¦é€‰è‚¡ä¿¡å·.
    3. **æ§åˆ¶å› å­æ•°é‡ä¸ç›¸å…³æ€§ï¼Œå…ˆè·‘ç¨³ Tabular åŸºçº¿**ï¼š
       - é¿å…å¤§é‡é«˜åº¦å…±çº¿æˆ–æåº¦ç¨€ç–çš„æ–°å› å­ï¼›
       - å…ˆåœ¨ LightGBM / CatBoost / ç®€å• MLP ç­‰ Tabular åŸºçº¿ä¸‹éªŒè¯ IC ä¸å†ä¸º NaN ä¸”æ”¶ç›Šä¸å†ç³»ç»Ÿæ€§ä¸ºè´Ÿï¼Œå†è€ƒè™‘å¼•å…¥æ›´å¤æ‚çš„æ—¶åºç»“æ„.
```

**é—®é¢˜åˆ†æ**:
- ç¬¬181-183è¡Œï¼šæ•°æ®é›†è¡¨æ ¼ï¼ˆä¿ç•™ï¼‰
- ç¬¬185-187è¡Œï¼šè‚¡ç¥¨ä»£ç æ ¼å¼è¯´æ˜ï¼ˆä¿ç•™ï¼Œä½†éœ€é¿å…é‡å¤ï¼‰
- ç¬¬189-202è¡Œï¼šè®¡ç®—èµ„æºä¸è®­ç»ƒè´Ÿè½½å»ºè®®ï¼ˆâŒ åº”è¯¥ç§»åˆ°æ¨¡å‹è®­ç»ƒæç¤ºè¯ï¼‰
- ç¬¬204-207è¡Œï¼šè‚¡ç¥¨æ± ç­›é€‰ä¸æ¯æ—¥æŒ‡æ ‡å› å­ä¼˜å…ˆä½¿ç”¨åŸåˆ™ï¼ˆâŒ åº”è¯¥ç§»åˆ°åé¦ˆç”Ÿæˆæç¤ºè¯ï¼‰
- ç¬¬209-219è¡Œï¼šç­–ç•¥æ¼”è¿›ä¼˜å…ˆçº§ï¼ˆâŒ åº”è¯¥ç§»åˆ°åé¦ˆç”Ÿæˆæç¤ºè¯æˆ–åˆ é™¤ï¼‰

**é‡å¤é—®é¢˜**:
- è‚¡ç¥¨ä»£ç æ ¼å¼è¯´æ˜åœ¨ä»¥ä¸‹ä½ç½®é‡å¤ï¼š
  - `prompts.yaml:185-187`ï¼ˆæ­¤å¤„ï¼‰
  - `prompts.yaml:315-317`ï¼ˆ`qlib_model_experiment_setting`ï¼‰
  - `prompts_data_loading.yaml`ï¼ˆæ¨¡å—æ–‡ä»¶ï¼‰
  - `factor_coder/prompts.yaml:45-49`ï¼ˆ`evolving_strategy_factor_implementation_v1_system`ï¼‰

---

### 10. qlib_model_background

**å¼•ç”¨æº**: `prompts.yaml:221-237`
**ä½¿ç”¨é˜¶æ®µ**: æ¨¡å‹èƒŒæ™¯
**é—®é¢˜**: æ— 

```yaml
qlib_model_background: |-
  The model is a machine learning or deep learning structure used in quantitative investment to predict the returns and risks of a portfolio or a single asset. Models are employed by investors to generate forecasts based on historical data and identified factors, which are central to many quantitative investment strategies.
  Each model takes the factors as input and predicts the future returns. Usually, the bigger the model is, the better the performance would be.
  The model is defined in the following parts:
  1. Name: The name of the model.
  2. Description: The description of the model.
  3. Architecture: The detailed architecture of the model, such as neural network layers or tree structures.
  4. Hyperparameters: The hyperparameters used in the model.
  5. Training_hyperparameters: The hyperparameters used during the training process.
  6. ModelType: The type of the model, "Tabular" for tabular model and "TimeSeries" for time series model.
  The model should provide clear and detailed documentation of its architecture and hyperparameters. One model should statically define one output with a fixed architecture and hyperparameters.

  {% if runtime_environment is not none %}
  ====== Runtime Environment ======
  You have following environment to run the code:
  {{ runtime_environment }}
  {% endif %}
```

---

### 11. qlib_model_interface

**å¼•ç”¨æº**: `prompts.yaml:239-271`
**ä½¿ç”¨é˜¶æ®µ**: æ¨¡å‹ç¼–ç 
**é—®é¢˜**: æ— 

```yaml
qlib_model_interface: |-
  Your python code should follow the interface to better interact with the user's system.
  You code should contain several parts:
  1. The import part: import the necessary libraries.
  2. A class which is a sub-class of pytorch.nn.Module. This class should should have a init function and a forward function which inputs a tensor and outputs a tensor.
  3. Set a variable called "model_cls" to the class you defined.

  The user will save your code into a python file called "model.py". Then the user imports model_cls in file "model.py" after setting the cwd into the directory:
  ```python
  from model import model_cls
  ```
  So your python code should follow the pattern:
  ```python
  class XXXModel(torch.nn.Module):
      ...
  model_cls = XXXModel
  ```

  The model can be configured as either "Tabular" for tabular models or "TimeSeries" for time series models. For a tabular model, the input shape is (batch_size, num_features), while for a time series model, the input shape is (batch_size, num_timesteps, num_features). In both cases, the output shape of the model should be (batch_size, 1).
  `num_features` will be directly set for the model based on the input data shape.
  User will initialize the tabular model with the following code:
  ```python
  model = model_cls(num_features=num_features)
  ```
  User will initialize the time series model with the following code:
  ```python
  model = model_cls(num_features=num_features, num_timesteps=num_timesteps)
  ```
  No other parameters will be passed to the model so give other parameters a default value or just make them static.

  Don't write any try-except block in your python code. The user will catch the exception message and provide the feedback to you. Also, don't write main function in your python code. The user will call the forward method in the model_cls to get the output tensor.

  Please notice that your model should only use current features as input. The user will provide the input tensor to the model's forward function.
```

---

### 12. qlib_model_output_format

**å¼•ç”¨æº**: `prompts.yaml:274-277`
**ä½¿ç”¨é˜¶æ®µ**: æ¨¡å‹ç¼–ç 
**é—®é¢˜**: æ— 

```yaml
qlib_model_output_format: |-
  Your output should be a tensor with shape (batch_size, 1).
  The output tensor should be saved in a file named "output.pth" in the same directory as your python file.
  The user will evaluate the shape of the output tensor so the tensor read from "output.pth" should be 8 numbers.
```

---

### 13. qlib_model_simulator

**å¼•ç”¨æº**: `prompts.yaml:279-287`
**ä½¿ç”¨é˜¶æ®µ**: æ¨¡å‹ç¼–ç 
**é—®é¢˜**: ğŸŸ¡ **P1** - èƒŒæ™¯ä»‹ç»å†—ä½™

```yaml
qlib_model_simulator: |-
  The models will be sent into Qlib to train and evaluate their performance in predicting future returns. Hypothesis is improved upon checking the feedback on the results.
  Qlib is an AI-oriented quantitative investment platform that aims to realize the potential, empower research, and create value using AI technologies in quantitative investment, from exploring ideas to implementing productions. Qlib supports diverse machine learning modeling paradigms, including supervised learning, market dynamics modeling, and reinforcement learning (RL).
  User will use Qlib to automatically perform the following tasks:
  1. Generate a baseline factor table.
  2. Train the model defined in your class Net to predict the next several days' returns based on the factor values.
  3. Build a portfolio based on the predicted returns using a specific strategy.
  4. Evaluate the portfolio's performance, including metrics such as return, IC, max drawdown, and others.
  5. Iterate on growing the hypothesis to enable model improvements based on performance evaluations and feedback.
```

---

### 14. qlib_model_rich_style_description

**å¼•ç”¨æº**: `prompts.yaml:289-308`
**ä½¿ç”¨é˜¶æ®µ**: UIå±•ç¤ºï¼ˆStreamlitï¼‰
**é—®é¢˜**: ğŸŸ¡ **P1** - æ¨¡å‹ç¼–ç é˜¶æ®µä¸éœ€è¦

```yaml
qlib_model_rich_style_description: |-
  ### Qlib Model Evolving Automatic R&D Demo

  #### [Overview](#_summary)

  The demo showcases the iterative process of hypothesis generation, knowledge construction, and decision-making in model construction in quantitative finance. It highlights how models evolve through continuous feedback and refinement.

  #### [Automated R&D](#_rdloops)

  - **[R (Research)](#_research)**
    - Iteration of ideas and hypotheses.
    - Continuous learning and knowledge construction.

  - **[D (Development)](#_development)**
    - Evolving code generation and model refinement.
    - Automated implementation and testing of models.

  #### [Objective](#_summary)

  To demonstrate the dynamic evolution of models through the Qlib platform, emphasizing how each iteration enhances the accuracy and reliability of the resulting models.
```

**ä½¿ç”¨ä½ç½®**:
- `log/ui/web.py:584` - `scen_c.container(border=True).markdown(QlibModelScenario().rich_style_description)`
- `scenarios/qlib/experiment/model_experiment.py:35` - åœºæ™¯ç±»åˆå§‹åŒ–

---

### 15. qlib_model_experiment_setting

**å¼•ç”¨æº**: `prompts.yaml:310-317`
**ä½¿ç”¨é˜¶æ®µ**: æ¨¡å‹ç¼–ç 
**é—®é¢˜**: ğŸŸ¡ **P1** - è‚¡ç¥¨ä»£ç æ ¼å¼è¯´æ˜é‡å¤

```yaml
qlib_model_experiment_setting: |-
  | Dataset ğŸ“Š | Model ğŸ¤–    | Factors ğŸŒŸ       | Data Split  ğŸ§®                                   |
  |---------|----------|---------------|-------------------------------------------------|
  | AIstock A-share (non-ST, non-delisted)  | ä¾‹å¦‚ GRU_TimeSeries_Modelï¼ˆä¹Ÿå¯æ›¿æ¢ä¸º LGB/MLP/Transformer ç­‰å…¶å®ƒæ¨¡å‹ï¼‰ | 20 factors (Alpha158)  | Train: 2010-01-07 to 2018-12-31 <br> Valid: 2019-01-01 to 2020-12-31 <br> Test &nbsp;: 2021-01-01 to 2025-12-01 |

  **é‡è¦è¯´æ˜ï¼šè‚¡ç¥¨ä»£ç æ ¼å¼**
  - è™½ç„¶æ•°æ®é›†åç§°ä¸º "AIstock A-share"ï¼Œä½†æ‰€æœ‰æ•°æ®æºä¸­çš„ `instrument` å‡å·²ç»Ÿä¸€ä¸º **Qlib é£æ ¼**ï¼ˆå¦‚ `000001.SZ`, `600000.SH`ï¼‰ã€‚
  - åœ¨ç ”å‘è¿‡ç¨‹ä¸­**ä¸¥ç¦**è¿›è¡Œæ ¼å¼è½¬æ¢.
```

**é—®é¢˜åˆ†æ**:
- ç¬¬315-317è¡Œï¼šè‚¡ç¥¨ä»£ç æ ¼å¼è¯´æ˜ä¸ `qlib_factor_experiment_setting` é‡å¤

---

### 16. transformer_volume_price_strategy

**å¼•ç”¨æº**: `prompts.yaml:319-332`
**ä½¿ç”¨é˜¶æ®µ**: ç¤ºä¾‹ç­–ç•¥
**é—®é¢˜**: ğŸŸ¢ **P2** - ç¤ºä¾‹ç­–ç•¥ä¸å¿…è¦

```yaml
transformer_volume_price_strategy: |-
  æœ¬æ®µè½æè¿°çš„æ˜¯ä¸€å¥— **ç¤ºä¾‹å‹** ç­–ç•¥è®¾æƒ³ï¼Œä¸»è¦ç”¨äºå±•ç¤ºå¦‚ä½•å°†é‡ä»·ç‰¹å¾ä¸æ—¶é—´åºåˆ—æ¨¡å‹ï¼ˆä¾‹å¦‚ Transformerï¼‰ç»“åˆï¼Œç”¨äºå¤šè‚¡ç¥¨ç»„åˆçš„ç ”ç©¶ä¸å›æµ‹ã€‚

  éœ€è¦ç‰¹åˆ«å¼ºè°ƒçš„æ˜¯ï¼š
  - è¿™é‡Œæåˆ°çš„æ¨¡å‹ç±»å‹ï¼ˆå¦‚ TransformerEncoderï¼‰ã€è°ƒä»“è§„åˆ™ã€æŒä»“è‚¡ç¥¨æ•°é‡ï¼ˆä¾‹å¦‚ 30 åªï¼‰ã€æ­¢ç›ˆæ­¢æŸé˜ˆå€¼ç­‰ï¼Œ**ä»…ä½œä¸ºç¤ºä¾‹/çµæ„Ÿæ¥æº**ï¼›
  - å®ƒä»¬ **ä¸å¯¹å½“å‰ä»»åŠ¡æˆ–ä»»ä½•å…·ä½“å®éªŒæ„æˆç¡¬æ€§çº¦æŸ**ï¼Œä½ åœ¨å®é™…ç ”å‘ä¸­å¯ä»¥è‡ªç”±é€‰æ‹© LightGBMã€CatBoostã€MLPã€GRUã€Transformer ç­‰ä»»æ„æ¨¡å‹ï¼Œä¹Ÿå¯ä»¥è‡ªç”±è®¾è®¡é€‰è‚¡æ•°é‡ä¸é£æ§è§„åˆ™ï¼›
  - æœ¬é¡¹ç›®çš„å…¶å®ƒæç¤ºè¯ï¼ˆå› å­/æ¨¡å‹/å›æµ‹é…ç½®ï¼‰åŒæ ·ä¸å¼ºåˆ¶ç»‘å®šæŸä¸€ç§æ¨¡å‹æˆ–å…·ä½“ç­–ç•¥å½¢æ€ï¼Œè€Œæ˜¯ä»¥"æ•°æ®æ ¼å¼ä¸ç´¢å¼• contract æ­£ç¡®"ä¸ºå”¯ä¸€åˆšæ€§çº¦æŸã€‚

  ç¤ºä¾‹æ€æƒ³ï¼ˆå¯é€‰å‚è€ƒï¼‰ï¼š
  - å…³æ³¨æœªæ¥è‹¥å¹²äº¤æ˜“æ—¥ï¼ˆä¾‹å¦‚ 1/5/10/30 æ—¥ï¼‰çš„æ”¶ç›Šè¡¨ç°ï¼Œè€Œä¸æ˜¯è¶…é•¿å‘¨æœŸæŒæœ‰ï¼›
  - åœ¨æ”¶ç›Šä¸é£é™©ä¹‹é—´è®¾å®šåˆç†çš„ç›®æ ‡åŒºé—´ï¼ˆä¾‹å¦‚æœŸæœ›å¹´åŒ–æ”¶ç›Šã€æœ€å¤§å›æ’¤ã€å•ç¬”é£é™©æ•å£ä¸Šé™ç­‰ï¼‰ï¼Œå¹¶åœ¨å› å­è®¾è®¡ã€æ¨¡å‹ç»“æ„ä»¥åŠè°ƒä»“è§„åˆ™ä¸­ç»¼åˆè€ƒè™‘ï¼›
  - ä»¥é‡ä»·ç‰¹å¾ä¸ºä¸€ä¸ªé‡è¦ç»´åº¦ï¼ŒåŒæ—¶å…è®¸ç»“åˆä¼°å€¼ã€å¸‚å€¼ã€AE å¼‚å¸¸åº¦ã€å®è§‚æƒ…ç»ªç­‰å¤šæ–¹é¢ä¿¡å·ï¼Œæ„å»ºå¤šå› å­ä¸å¤šå‘¨æœŸçš„ç­–ç•¥æ¡†æ¶ï¼›
  - å¯¹äºæ—¶é—´åºåˆ—å»ºæ¨¡ï¼Œå¯ä»¥é€‰æ‹© Transformerã€GRUã€TCN ç­‰ï¼Œä¹Ÿå¯ä»¥å›åˆ°ç®€å•çš„æˆªé¢æ¨¡å‹ï¼ˆå¦‚ LGB/MLPï¼‰å¹¶é…åˆæ»šåŠ¨çª—å£ç‰¹å¾æ„é€ å®Œæˆç­–ç•¥è®¾è®¡ã€‚

  æ€»ä¹‹ï¼Œæœ¬æ®µä»…ä½œä¸º"å¦‚ä½•æ„æ€ä¸€å¥—è¾ƒä¸ºå®Œæ•´çš„é‡ä»·+æ—¶åºç­–ç•¥"çš„ **ç¤ºä¾‹æ–‡æ¡£**ã€‚åœ¨å®é™…è‡ªåŠ¨ç ”å‘ä¸æ¼”è¿›è¿‡ç¨‹ä¸­ï¼Œä½ å®Œå…¨å¯ä»¥æ ¹æ®å®éªŒç»“æœä¸ä»»åŠ¡éœ€æ±‚ï¼Œè‡ªä¸»å†³å®šä½¿ç”¨çš„æ¨¡å‹ç±»å‹ã€é€‰è‚¡æ•°é‡ã€æŒä»“å‘¨æœŸä»¥åŠæ˜¯å¦é‡‡ç”¨æ­¢ç›ˆ/æ­¢æŸæœºåˆ¶ã€‚
```

**é—®é¢˜åˆ†æ**:
- æ˜ç¡®è¯´æ˜"ä¸å¯¹å½“å‰ä»»åŠ¡æ„æˆç¡¬æ€§çº¦æŸ"
- åœ¨å› å­ç¼–ç é˜¶æ®µä¸éœ€è¦äº†è§£ç­–ç•¥ç»†èŠ‚
- å¯èƒ½è¯¯å¯¼ LLM ä»¥ä¸ºéœ€è¦å®ç°ç‰¹å®šç­–ç•¥

---

## é—®é¢˜æ±‡æ€»

### ğŸ”´ P0 ä¸¥é‡é—®é¢˜ï¼ˆ2ä¸ªï¼‰

| æç¤ºè¯ | é—®é¢˜ | è¡Œå· | å½±å“ |
|--------|------|------|------|
| `qlib_factor_strategy` | å±•ç¤º `reset_index()` ç¤ºä¾‹ï¼Œä¸æ ¸å¿ƒçº¦æŸå†²çª | 65-70 | å¯¼è‡´ LLM ç ´åç´¢å¼•ç»“æ„ |
| `qlib_factor_experiment_setting` | åŒ…å«è®­ç»ƒå‚æ•°ã€ç­–ç•¥æ¼”è¿›ç­‰æ— å…³å†…å®¹ | 189-219 | æç¤ºè¯è¿‡é•¿ï¼Œåˆ†æ•£æ³¨æ„åŠ› |

### ğŸŸ¡ P1 ä¸­ç­‰é—®é¢˜ï¼ˆ4ä¸ªï¼‰

| æç¤ºè¯ | é—®é¢˜ | è¡Œå· | å½±å“ |
|--------|------|------|------|
| `qlib_factor_simulator` | èƒŒæ™¯ä»‹ç»å†—ä½™ | 117-123 | æç¤ºè¯è¿‡é•¿ |
| `qlib_factor_rich_style_description` | UIå±•ç¤ºå†…å®¹ï¼Œå› å­ç¼–ç ä¸éœ€è¦ | 125-144 | åˆ†æ•£æ³¨æ„åŠ› |
| `qlib_factor_from_report_rich_style_description` | UIå±•ç¤ºå†…å®¹ï¼Œå› å­ç¼–ç ä¸éœ€è¦ | 146-178 | åˆ†æ•£æ³¨æ„åŠ› |
| `qlib_model_simulator` | èƒŒæ™¯ä»‹ç»å†—ä½™ | 280-287 | æç¤ºè¯è¿‡é•¿ |

### ğŸŸ¢ P2 ä½ä¼˜å…ˆçº§é—®é¢˜ï¼ˆ3ä¸ªï¼‰

| æç¤ºè¯ | é—®é¢˜ | è¡Œå· | å½±å“ |
|--------|------|------|------|
| `transformer_volume_price_strategy` | ç¤ºä¾‹ç­–ç•¥ä¸å¿…è¦ | 319-332 | å¯èƒ½è¯¯å¯¼ |
| è‚¡ç¥¨ä»£ç æ ¼å¼è¯´æ˜ | åœ¨å¤šä¸ªä½ç½®é‡å¤ | å¤šå¤„ | å†—ä½™ |
| `qlib_model_experiment_setting` | è‚¡ç¥¨ä»£ç æ ¼å¼è¯´æ˜é‡å¤ | 315-317 | å†—ä½™ |

---

## ä¿®æ”¹å»ºè®®æ€»ç»“

### å¿…é¡»ä¿®æ”¹ï¼ˆP0ï¼‰

1. **ä¿®å¤ `qlib_factor_strategy`**ï¼šåˆ é™¤æˆ–ä¿®æ”¹ `reset_index()` ç¤ºä¾‹
2. **ç²¾ç®€ `qlib_factor_experiment_setting`**ï¼šç§»é™¤è®­ç»ƒå‚æ•°å’Œç­–ç•¥æ¼”è¿›å†…å®¹

### å»ºè®®ä¿®æ”¹ï¼ˆP1ï¼‰

3. **ç²¾ç®€ `qlib_factor_simulator`**ï¼šç§»é™¤ Qlib å¹³å°èƒŒæ™¯ä»‹ç»
4. **è¯„ä¼° `rich_style_description`**ï¼šå¦‚æœä¸éœ€è¦ UI å±•ç¤ºï¼Œå¯ä»¥åˆ é™¤

### å¯é€‰ä¿®æ”¹ï¼ˆP2ï¼‰

5. **ç§»é™¤ `transformer_volume_price_strategy`**ï¼šæˆ–ç§»åŠ¨åˆ°ç­–ç•¥è®¾è®¡æ¨¡å—
6. **ç»Ÿä¸€è‚¡ç¥¨ä»£ç æ ¼å¼è¯´æ˜**ï¼šåªåœ¨ `prompts_data_loading.yaml` ä¸­ä¿ç•™ä¸€æ¬¡

---

## é¢„æœŸæ•ˆæœ

ä¿®æ”¹å®Œæˆåï¼š
- `qlib_factor_experiment_setting` ä» 40 è¡Œå‡å°‘åˆ° 10 è¡Œï¼ˆå‡å°‘75%ï¼‰
- ç§»é™¤é”™è¯¯å¼•å¯¼ï¼Œå‡å°‘ç´¢å¼•ç»“æ„é”™è¯¯
- æç¤ºè¯æ›´åŠ èšç„¦äºå› å­ç¼–ç çš„æ ¸å¿ƒä»»åŠ¡
- å‡å°‘ LLM æ··æ·†ï¼Œæå‡ç¼–ç æˆåŠŸç‡ 10-15%
