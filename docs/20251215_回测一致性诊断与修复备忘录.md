# 20251215_回测一致性诊断与修复备忘录

## 1. 背景与问题陈述

在 RD-Agent + Qlib 场景下，多轮任务/不同 loop 出现“回测结果高度一致/重复”。目标是确保 **今后所有回测必须使用当前 loop 生成的因子或策略**，不得再使用固定因子文件导致“假演进”。

## 2. 现场证据（workspace 取证）

### 2.1 多 workspace 的 conf 与结果一致性特征

- 多个 workspace 的 `conf_combined_factors.yaml` 中 `static_path` 完全一致：
  - `static_path: /mnt/c/Users/lc999/NewAIstock/AIstock/factors/combined_static_factors.parquet`
- 多个 workspace 的关键指标形成若干“簇”（A/B/C/D），同簇内数值仅末位浮动，说明输入链路基本不变。

### 2.2 关键实锤：产物存在但未被回测消费

以 `WS=096ea9664602408f987da3ddb65473fe` 为例：

- `conf_combined_factors.yaml` 明确指定：
  - `provider_uri: /mnt/c/Users/lc999/NewAIstock/AIstock/qlib_bin/qlib_bin_20251209`
  - `static_path: /mnt/c/Users/lc999/NewAIstock/AIstock/factors/combined_static_factors.parquet`
- 同一 workspace 下实际生成了：
  - `combined_factors_df.parquet`（loop 合成因子产物）
  - `qlib_res.csv` / `ret.pkl`
- 但 `conf_combined_factors.yaml` 并未引用 `combined_factors_df.parquet`。

结论：**“生成了新因子”与“回测使用了新因子”链路断开**，回测主输入为固定 `static_path` 指向的静态表。

## 3. 根因定位（源码责任链）

### 3.1 直接责任：runner 选择了固定 static_path 的 YAML

- 文件：`rdagent/scenarios/qlib/developer/factor_runner.py`
- 逻辑：在 **LGBM + combined factors** 分支中，原代码选择：
  - `conf_combined_factors.yaml`
- 该 YAML 使用 `CombinedAlpha158StaticLoader` 并指定 `static_path`，因此回测不使用 loop 产物 `combined_factors_df.parquet`。

### 3.2 次级责任：配置文件本身固定 static_path

- 文件：`rdagent/scenarios/qlib/experiment/factor_template/conf_combined_factors.yaml`
- 包含：`static_path: .../combined_static_factors.parquet`

### 3.3 说明：这不是 Qlib 自身问题

Qlib 的行为是“按配置加载”。
- 若 data_loader 指向 workspace 内 `combined_factors_df.parquet`，Qlib 会读取该文件。
- 当前问题来自 RD-Agent 的“配置选择/衔接”，而非 Qlib 忽略产物。

## 4. 解决方案与代码修改（已落地）

目标：**强制每轮回测使用当前 loop 生成的因子/策略**，禁止固定因子文件。

### 4.1 新增：LGBM 动态 combined 因子配置

- 新增文件：
  - `rdagent/scenarios/qlib/experiment/factor_template/conf_combined_factors_dynamic.yaml`
- 核心：用 `NestedDataLoader` 组合：
  - `Alpha158DL`（基础特征/label）
  - `StaticDataLoader(config="combined_factors_df.parquet")`（读取 workspace 内 loop 产物）
- 模型：仍为 `LGBModel`（保持最小变量变化）

### 4.2 修改：LGBM combined 分支切换到动态配置

- 文件：`rdagent/scenarios/qlib/developer/factor_runner.py`
- 变更：
  - `conf_combined_factors.yaml` -> `conf_combined_factors_dynamic.yaml`

### 4.3 增加硬约束：禁止执行含 `static_path:` 的配置

- 文件：`rdagent/scenarios/qlib/experiment/workspace.py`（`QlibFBWorkspace.execute`）
- 变更：执行 `qrun` 前读取配置文本，若包含 `static_path:` 直接抛错：
  - 防止任何分支/未来改动回退到固定因子文件方案

## 5. 为什么本次主要改 LGBM 分支？其他分支是否有类似问题？

- 本次“固定因子表导致回测一致”的问题，出现在 `QlibFactorRunner` 的 **LGBM combined** 分支选择了 `conf_combined_factors.yaml`。
- 其它分支情况：
  - **SOTA model 分支**（`conf_combined_factors_sota_model.yaml`）本身已读取 `combined_factors_df.parquet`，不存在“固定 static_path”的输入链路。
  - **Model 相关配置**（如 `model_template/conf_sota_factors_model.yaml`）也已读取 `combined_factors_df.parquet`。
  - 当前代码库内出现 `static_path:` 的位置主要集中在：
    - `factor_template/conf_combined_factors.yaml`
    - `experiment/custom_loaders.py`（loader 实现）
    - `experiment/workspace.py`（新增 guard）

结论：本次修改优先覆盖了“最常用且已确认错误”的 LGBM combined 链路，同时通过 guard 机制防止其它分支未来引入同类错误。

## 6. 回溯与潜在副作用检查（快速审计）

### 6.1 新 guard 的影响面

- 任何 yaml 内出现 `static_path:` 都会被拒绝执行。
- 当前仓库中实际会被执行且包含 `static_path:` 的主要是 `conf_combined_factors.yaml`。
- 这符合“不得使用固定因子文件”的硬要求，但意味着：
  - 如果你未来确实需要引入某类固定因子（例如生产基线），需要显式设计“允许列表/开关”，否则会被 guard 拦截。

### 6.2 新增 YAML 的依赖与兼容性

- `conf_combined_factors_dynamic.yaml` 使用 `StaticDataLoader(config="combined_factors_df.parquet")`。
- 依赖：workspace 中必须存在 `combined_factors_df.parquet`（由 factor_runner 已生成）。
- 风险：
  - 若某些异常路径未生成 parquet，qrun 会失败（这是合理失败，能暴露链路问题）。

### 6.3 其他未在本次修复范围内的风险点

- `read_exp_res.py` 的“全局最新 recorder 选择”逻辑仍可能导致读错 recorder（属于另一条风险链路，需单独修复）。

## 7. 验证步骤（建议）

1) 启动一次新任务/新 loop。
2) 在生成的 workspace 中确认存在：
   - `combined_factors_df.parquet`
3) 确认回测使用的配置为：
   - `conf_combined_factors_dynamic.yaml`
4) 若有人误用 `conf_combined_factors.yaml`：
   - 应触发 `Refusing to run ... because it contains 'static_path:'` 的异常，证明 guard 生效。

## 8. 结论

- 回测一致的根因是：**RD-Agent LGBM combined 分支选择了固定 static_path 的配置**，导致 loop 产物未被消费。
- 修复已落地：
  - 新增 LGBM 动态配置读取 `combined_factors_df.parquet`
  - runner 切换到动态配置
  - workspace 执行层加入 `static_path` 禁用 guard，机制性防回归
