# 因子演进中模型选择对因子评估的影响分析

## 实施日期
2026-01-14

## 1. 问题提出

### 1.1 当前问题

用户提出了一个关键问题：

> "分析因子演进过程中使用不同的模型，是否会影响因子效果的判断？不同因子使用不同的模型，缺乏横向比较的依据，是否可以先运行一个因子任务，获取SOTA因子列表，后续使用这些SOTA因子和alpha22因子，再继续做不同模型的演进？可以分开评估因子和模型，也更直观反应哪些模型或因子更应该进入SOTA"

### 1.2 核心问题

**问题1：模型选择对因子评估的影响**

如果在因子演进过程中使用不同的模型，那么因子的性能评估会受到模型的影响：

| 因子 | 模型 | IC | 因子效果判断 |
|-----|------|----|------------|
| 因子A | LGBM | 0.05 | 基准 |
| 因子B | XGBoost | 0.06 | 比因子A好？❌ |
| 因子C | RandomForest | 0.04 | 比因子A差？❌ |

**问题**：无法判断是因子本身的性能好，还是模型更适配这个因子。

**问题2：缺乏横向比较的依据**

不同因子使用不同模型，无法进行公平的横向比较：
- 因子A的IC=0.05（LGBM） vs 因子B的IC=0.06（XGBoost）
- 不能直接说因子B比因子A好
- 缺乏统一的评估标准

**问题3：SOTA因子的选择标准不明确**

如果不同因子使用不同模型，那么进入SOTA的因子可能是因为：
- 因子本身性能好
- 模型更适配这个因子
- 两者都有

无法准确判断是哪个因素导致的性能提升。

## 2. 用户提出的两阶段方案

### 2.1 方案描述

**第一阶段：因子演进（固定模型）**
- 使用固定模型（如LGBM）进行因子演进
- 获取SOTA因子列表
- 所有因子使用相同的模型，确保公平比较

**第二阶段：模型演进（固定因子集）**
- 使用SOTA因子+Alpha22因子
- 进行不同模型的演进
- 所有模型使用相同的因子集，确保公平比较

### 2.2 方案优势

**优势1：分开评估因子和模型**

| 阶段 | 评估对象 | 固定变量 | 可变变量 | 评估指标 |
|-----|---------|---------|---------|---------|
| 第一阶段 | 因子 | 模型（LGBM） | 因子 | IC |
| 第二阶段 | 模型 | 因子集（SOTA+Alpha22） | 模型 | IC |

**优势2：横向比较的依据**

- **因子比较**：所有因子使用相同的模型，可以直接比较IC
- **模型比较**：所有模型使用相同的因子集，可以直接比较IC

**优势3：更直观的SOTA判断**

- **SOTA因子**：基于固定模型的性能，真正反映因子质量
- **SOTA模型**：基于固定因子集的性能，真正反映模型能力

**优势4：避免混淆**

- 不会因为模型更适配某个因子而误判因子性能
- 不会因为因子更适配某个模型而误判模型性能

### 2.3 方案流程

```
第一阶段：因子演进（固定模型）
┌─────────────────────────────────────────┐
│ 输入：Alpha22因子 + 新生成的因子          │
│ 模型：固定使用LGBM                        │
│ 输出：SOTA因子列表                        │
│ 评估：基于LGBM的IC对比                    │
└─────────────────────────────────────────┘
                    ↓
第二阶段：模型演进（固定因子集）
┌─────────────────────────────────────────┐
│ 输入：SOTA因子 + Alpha22因子              │
│ 因子集：固定                              │
│ 模型：LGBM, XGBoost, RandomForest, MLP   │
│ 输出：SOTA模型列表                        │
│ 评估：基于相同因子集的IC对比              │
└─────────────────────────────────────────┘
```

## 3. 当前方案 vs 两阶段方案对比

### 3.1 当前方案分析

**方案A：因子演进中使用不同模型**

| 维度 | 说明 |
|-----|------|
| **流程** | 因子演进时轮询使用不同模型 |
| **因子评估** | 不同因子使用不同模型，无法公平比较 |
| **模型评估** | 模型演进时使用SOTA因子，可以比较 |
| **SOTA因子** | 可能受模型影响，判断标准不明确 |
| **SOTA模型** | 基于SOTA因子，判断标准明确 |
| **优势** | 因子演进多样性高 |
| **劣势** | ❌ 因子评估不公平<br>❌ 缺乏横向比较依据<br>❌ SOTA因子判断标准不明确 |

**示例问题**：

```
Loop 1: 因子A + LGBM → IC=0.05 → 进入SOTA
Loop 2: 因子B + XGBoost → IC=0.06 → 进入SOTA
Loop 3: 因子C + RandomForest → IC=0.04 → 不进入SOTA

问题：
- 因子B的IC=0.06是因为因子B好，还是XGBoost好？
- 如果因子B用LGBM测试，IC可能是0.04
- 如果因子A用XGBoost测试，IC可能是0.07
- 无法准确判断哪个因子真正更好
```

### 3.2 两阶段方案分析

**方案B：两阶段分离评估**

| 维度 | 说明 |
|-----|------|
| **流程** | 第一阶段：因子演进（固定模型）<br>第二阶段：模型演进（固定因子集） |
| **因子评估** | 所有因子使用相同模型，公平比较 |
| **模型评估** | 所有模型使用相同因子集，公平比较 |
| **SOTA因子** | 基于固定模型，判断标准明确 |
| **SOTA模型** | 基于固定因子集，判断标准明确 |
| **优势** | ✅ 因子评估公平<br>✅ 模型评估公平<br>✅ 有明确的横向比较依据<br>✅ SOTA判断标准明确 |
| **劣势** | 需要分两阶段实施 |

**示例优势**：

```
第一阶段：因子演进（固定LGBM）
Loop 1: 因子A + LGBM → IC=0.05 → 进入SOTA
Loop 2: 因子B + LGBM → IC=0.06 → 进入SOTA
Loop 3: 因子C + LGBM → IC=0.04 → 不进入SOTA

结论：因子B > 因子A > 因子C（基于相同模型）

第二阶段：模型演进（固定SOTA因子+Alpha22）
LGBM + SOTA因子 → IC=0.07
XGBoost + SOTA因子 → IC=0.08
RandomForest + SOTA因子 → IC=0.06
MLP + SOTA因子 → IC=0.05

结论：XGBoost > LGBM > RandomForest > MLP（基于相同因子集）

最终SOTA：
- SOTA因子：因子A, 因子B（基于LGBM性能）
- SOTA模型：XGBoost（基于SOTA因子性能）
```

### 3.3 方案对比总结

| 维度 | 当前方案（A） | 两阶段方案（B） | 优势方 |
|-----|--------------|----------------|-------|
| **因子评估公平性** | ❌ 不同因子用不同模型 | ✅ 所有因子用相同模型 | B |
| **模型评估公平性** | ✅ 基于SOTA因子 | ✅ 基于SOTA因子 | 平手 |
| **横向比较依据** | ❌ 缺乏 | ✅ 明确 | B |
| **SOTA因子判断** | ❌ 受模型影响 | ✅ 基于固定模型 | B |
| **SOTA模型判断** | ✅ 基于SOTA因子 | ✅ 基于SOTA因子 | 平手 |
| **实施复杂度** | 低 | 中等 | A |
| **时间成本** | 低 | 中等 | A |
| **结果可靠性** | 低 | 高 | B |

**结论**：两阶段方案（B）在评估公平性和结果可靠性方面明显优于当前方案（A），虽然实施复杂度和时间成本略高，但收益显著。

## 4. 两阶段方案实施建议

### 4.1 实施方案

#### 方案1：完全分离的两阶段方案

**第一阶段：因子演进（固定LGBM）**

```python
# factor_runner.py
def develop(self, exp: QlibFactorExperiment) -> QlibFactorExperiment:
    # ... 因子处理逻辑 ...
    
    # 第一阶段：固定使用LGBM评估因子
    if not exist_sota_model_exp:
        # 强制使用LGBM，不使用其他模型
        qlib_config_name = "conf_baseline.yaml"  # LGBM配置
        result, stdout = exp.experiment_workspace.execute(
            qlib_config_name=qlib_config_name
        )
```

**第二阶段：模型演进（使用SOTA因子+Alpha22）**

```python
# model_runner.py
def develop(self, exp: QlibModelExperiment) -> QlibModelExperiment:
    # ... SOTA因子处理逻辑 ...
    
    # 第二阶段：使用SOTA因子+Alpha22，测试不同模型
    if exist_sota_factor_exp:
        # 测试多个模型
        model_configs = [
            "conf_sota_factors_lgbm.yaml",    # LGBM
            "conf_sota_factors_xgb.yaml",     # XGBoost
            "conf_sota_factors_rf.yaml",      # RandomForest
            "conf_sota_factors_mlp.yaml",     # MLP
        ]
        
        # 选择性能最好的模型
        best_config, best_result, best_stdout = self._test_multiple_models(
            exp, model_configs
        )
```

**优点**：
- ✅ 完全分离因子和模型评估
- ✅ 评估公平性最高
- ✅ 结果最可靠

**缺点**：
- ❌ 需要修改较多代码
- ❌ 实施复杂度较高

#### 方案2：环境变量控制的两阶段方案

**第一阶段：因子演进（固定LGBM）**

```python
# factor_runner.py
def develop(self, exp: QlibFactorExperiment) -> QlibFactorExperiment:
    # ... 因子处理逻辑 ...
    
    # 通过环境变量控制是否使用多模型
    use_multiple_models = os.getenv("USE_MULTIPLE_MODELS_IN_FACTOR", "false") == "true"
    
    if not exist_sota_model_exp and not use_multiple_models:
        # 第一阶段：固定使用LGBM
        qlib_config_name = "conf_baseline.yaml"
        result, stdout = exp.experiment_workspace.execute(
            qlib_config_name=qlib_config_name
        )
    elif not exist_sota_model_exp and use_multiple_models:
        # 可选：使用多模型（第二阶段）
        qlib_config_name = get_model_config_for_factor(exp)
        result, stdout = exp.experiment_workspace.execute(
            qlib_config_name=qlib_config_name
        )
```

**第二阶段：模型演进（使用SOTA因子+Alpha22）**

```python
# model_runner.py
def develop(self, exp: QlibModelExperiment) -> QlibModelExperiment:
    # ... SOTA因子处理逻辑 ...
    
    # 通过环境变量控制是否测试多模型
    test_multiple_models = os.getenv("TEST_MULTIPLE_MODELS", "true") == "true"
    
    if exist_sota_factor_exp and test_multiple_models:
        # 第二阶段：测试多个模型
        model_configs = [...]
        best_config, best_result, best_stdout = self._test_multiple_models(
            exp, model_configs
        )
```

**优点**：
- ✅ 通过环境变量控制，灵活切换
- ✅ 可以分阶段实施
- ✅ 易于回退

**缺点**：
- ⚠️ 需要手动设置环境变量

#### 方案3：自动检测的两阶段方案

**自动检测阶段**：

```python
# factor_runner.py
def develop(self, exp: QlibFactorExperiment) -> QlibFactorExperiment:
    # ... 因子处理逻辑 ...
    
    # 自动检测当前阶段
    has_sota_factors = self._has_sota_factors(exp)
    has_sota_models = self._has_sota_models(exp)
    
    if not has_sota_factors and not has_sota_models:
        # 第一阶段：固定使用LGBM
        logger.info("第一阶段：因子演进，固定使用LGBM")
        qlib_config_name = "conf_baseline.yaml"
    elif has_sota_factors and not has_sota_models:
        # 第二阶段：测试多个模型
        logger.info("第二阶段：模型演进，测试多个模型")
        qlib_config_name = get_model_config_for_factor(exp)
    else:
        # 其他情况
        qlib_config_name = "conf_baseline.yaml"
```

**优点**：
- ✅ 自动检测，无需手动设置
- ✅ 用户体验好

**缺点**：
- ⚠️ 逻辑复杂，需要准确判断阶段

### 4.2 推荐方案：方案2 - 环境变量控制的两阶段方案

**推荐理由**：
1. ✅ 灵活性高：通过环境变量控制，可以随时切换
2. ✅ 易于实施：改动量适中
3. ✅ 易于回退：设置环境变量即可回退
4. ✅ 可分阶段实施：可以先实施第一阶段，再实施第二阶段

**实施步骤**：

**第一步：实施第一阶段（1-2天）**
1. 修改`factor_runner.py`，添加环境变量控制
2. 确保因子演进时固定使用LGBM
3. 测试验证

**第二步：实施第二阶段（3-5天）**
1. 修改`model_runner.py`，添加多模型测试逻辑
2. 创建多个模型配置文件
3. 测试验证

**第三步：运行验证（1-2周）**
1. 运行第一阶段，获取SOTA因子
2. 运行第二阶段，测试不同模型
3. 分析结果，验证方案效果

### 4.3 环境变量配置

```env
# 第一阶段：因子演进配置
# false: 固定使用LGBM（推荐）
# true: 使用多模型（不推荐）
USE_MULTIPLE_MODELS_IN_FACTOR=false

# 第二阶段：模型演进配置
# true: 测试多个模型（推荐）
# false: 只使用SOTA模型
TEST_MULTIPLE_MODELS=true

# Alpha因子叠加配置
USE_ALPHA_FACTORS=true
```

## 5. 预期效果

### 5.1 第一阶段：因子演进（固定LGBM）

**效果**：
- ✅ 所有因子使用相同的模型（LGBM）
- ✅ 因子评估公平，可以直接比较IC
- ✅ SOTA因子判断标准明确

**示例**：

| 因子 | 模型 | IC | 排名 | 是否进入SOTA |
|-----|------|----|----|------------|
| 因子A | LGBM | 0.05 | 2 | ✅ |
| 因子B | LGBM | 0.06 | 1 | ✅ |
| 因子C | LGBM | 0.04 | 3 | ❌ |

**结论**：因子B > 因子A > 因子C（基于相同模型）

### 5.2 第二阶段：模型演进（固定因子集）

**效果**：
- ✅ 所有模型使用相同的因子集（SOTA因子+Alpha22）
- ✅ 模型评估公平，可以直接比较IC
- ✅ SOTA模型判断标准明确

**示例**：

| 模型 | 因子集 | IC | 排名 | 是否进入SOTA |
|-----|-------|----|----|------------|
| LGBM | SOTA+Alpha22 | 0.07 | 2 | ✅ |
| XGBoost | SOTA+Alpha22 | 0.08 | 1 | ✅ |
| RandomForest | SOTA+Alpha22 | 0.06 | 3 | ❌ |
| MLP | SOTA+Alpha22 | 0.05 | 4 | ❌ |

**结论**：XGBoost > LGBM > RandomForest > MLP（基于相同因子集）

### 5.3 最终SOTA

**SOTA因子**：
- 因子A（IC=0.05，基于LGBM）
- 因子B（IC=0.06，基于LGBM）

**SOTA模型**：
- XGBoost（IC=0.08，基于SOTA因子+Alpha22）

**优势**：
- ✅ SOTA因子判断标准明确（基于固定模型）
- ✅ SOTA模型判断标准明确（基于固定因子集）
- ✅ 可以清楚地知道是因子好还是模型好

## 6. 风险控制

### 6.1 风险1：实施复杂度

**风险**：需要修改较多代码，实施复杂度较高

**应对**：
- 分阶段实施，先实施第一阶段，再实施第二阶段
- 使用环境变量控制，易于回退
- 充分测试，确保稳定性

### 6.2 风险2：时间成本

**风险**：第二阶段需要测试多个模型，时间成本增加

**应对**：
- 可以并行测试多个模型
- 可以只测试2-3个主要模型（LGBM, XGBoost, RandomForest）
- 可以设置超时，避免长时间等待

### 6.3 风险3：资源消耗

**风险**：测试多个模型会增加资源消耗

**应对**：
- 监控内存和CPU使用情况
- 可以限制并行测试的模型数量
- 可以在非高峰期运行

## 7. 结论

### 7.1 用户建议的价值

用户提出的两阶段方案具有以下价值：

1. ✅ **解决了因子评估公平性问题**：所有因子使用相同模型
2. ✅ **提供了横向比较的依据**：因子和模型都可以公平比较
3. ✅ **明确了SOTA判断标准**：SOTA因子和SOTA模型的判断标准都很明确
4. ✅ **可以分开评估因子和模型**：更直观地反应哪些模型或因子应该进入SOTA

### 7.2 最终建议

**强烈推荐采用两阶段方案**，理由如下：

1. ✅ **评估公平性高**：因子和模型都可以公平评估
2. ✅ **结果可靠性高**：SOTA判断标准明确
3. ✅ **实施可行性高**：可以通过环境变量控制，易于实施
4. ✅ **回退容易**：设置环境变量即可回退

**推荐实施方案**：方案2 - 环境变量控制的两阶段方案

**实施时间**：
- 第一阶段：1-2天
- 第二阶段：3-5天
- 总计：4-7天

**预期收益**：
- 因子评估公平性提升
- 模型评估公平性提升
- SOTA判断标准明确
- 结果可靠性提升

## 8. 附录

### 8.1 环境变量配置示例

```env
# 第一阶段：因子演进配置
USE_MULTIPLE_MODELS_IN_FACTOR=false

# 第二阶段：模型演进配置
TEST_MULTIPLE_MODELS=true

# Alpha因子叠加配置
USE_ALPHA_FACTORS=true
```

### 8.2 回滚方法

如果需要回退到原始行为，只需设置环境变量：

```bash
# 回退到原始行为
export USE_MULTIPLE_MODELS_IN_FACTOR=true
export TEST_MULTIPLE_MODELS=false
```

### 8.3 监控指标

**第一阶段监控指标**：
- 因子IC
- 因子排名
- 进入SOTA的因子数量

**第二阶段监控指标**：
- 模型IC
- 模型排名
- 进入SOTA的模型数量

## 9. 联系人

如有问题，请联系开发团队。

## 10. 版本历史

| 版本 | 日期 | 说明 |
|-----|------|------|
| v1.0 | 2026-01-14 | 初始版本，分析因子演进中模型选择对因子评估的影响，提出两阶段方案 |
