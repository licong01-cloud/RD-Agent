# 文档其他问题分析报告

## 一、问题回顾

根据《模型权重文件定位方案_v2.md》第十三节，主要问题包括：

1. **动态因子输入顺序缺失**：目前无法从 log/session 或 model_meta.json 恢复动态因子顺序；若禁用 combined_factors_df.parquet，则无法严格对齐训练输入顺序。
2. **SOTA 源码提取不确定性**：`_sync_factor_impl_to_shared_lib()` 依赖"因子名与代码定义名称一致"，对命名不匹配场景无保证。
3. **权重定位虽可行，但依赖 workspace 内 mlruns**：需要保证目标 workspace 未被清理，且 artifact_uri 可被访问。

## 二、问题1：动态因子输入顺序缺失

### 2.1 问题分析

**根本原因**：
- 动态因子通过 `CombinedAlpha158DynamicFactorsLoader` 使用 `dynamic_path=combined_factors_df.parquet` 加载
- 代码未提供单独的 "dynamic feature order list"
- `factor_meta.json` 和 `model_meta.json` **仅记录因子名称，不记录顺序**

### 2.2 解决方案验证

**已实施方案**：log-only同步方案（第十四章）

**验证方法**：
1. 查看实际数据：`f:/Dev/AIstock/rdagent_assets/rdagent_tasks/2025-12-18_16-24-29-487030/combined_factors_df.parquet`
2. 读取parquet元数据，提取列顺序
3. 验证是否可以生成 `factor_order.json`

**验证代码**：

```python
import pyarrow.parquet as pq

# 读取 combined_factors_df.parquet 的列顺序
parquet_path = "f:/Dev/AIstock/rdagent_assets/rdagent_tasks/2025-12-18_16-24-29-487030/combined_factors_df.parquet"
meta = pq.read_metadata(parquet_path)
all_cols = meta.schema.names

# 提取因子顺序（排除索引列）
factor_order = [name for name in all_cols 
               if name not in ("datetime", "instrument", "index", "level_0", "level_1")]

print(f"Total columns: {len(all_cols)}")
print(f"Factor columns: {len(factor_order)}")
print(f"First 10 factors: {factor_order[:10]}")
print(f"Last 10 factors: {factor_order[-10:]}")
```

**验证结果**：
- ✅ 可以从 parquet 文件读取列顺序
- ✅ 可以生成 `factor_order.json` 文件
- ✅ 实盘选股时可以从 `factor_order.json` 读取列顺序，无需读取 parquet

**结论**：问题1已通过log-only同步方案解决。

## 三、问题2：SOTA 源码提取不确定性

### 3.1 问题分析

**根本原因**：
- `_sync_factor_impl_to_shared_lib()` 在 workspace 内遍历 `*.py` 文件
- 通过正则匹配找到 `class/def <factor_name>` 或 `def calculate_<factor_name>` 的代码片段
- 如果因子名与代码定义名称不一致，就无法匹配到

### 3.2 解决方案验证

**验证方法**：
1. 查看实际的因子代码文件：`based_factor_0.py`, `based_factor_1.py`, `based_factor_2.py`, `based_factor_3.py`
2. 验证因子名是否与代码定义名称一致
3. 检查 `_sync_factor_impl_to_shared_lib()` 的匹配逻辑

**验证结果**：

**based_factor_0.py**：
```python
def calculate_MomentumVolAdj_20D():
    # ...
```
- 因子名：`MomentumVolAdj_20D`
- 代码定义：`calculate_MomentumVolAdj_20D`
- ✅ 匹配成功

**based_factor_1.py**：
```python
def calculate_mf_elg_net_amt_ratio_stability_5D():
    # ...
```
- 因子名：`mf_elg_net_amt_ratio_stability_5D`
- 代码定义：`calculate_mf_elg_net_amt_ratio_stability_5D`
- ✅ 匹配成功

**based_factor_2.py**：
```python
def calculate_SizeAdjTurnover_5D():
    # ...
```
- 因子名：`SizeAdjTurnover_5D`
- 代码定义：`calculate_SizeAdjTurnover_5D`
- ✅ 匹配成功

**based_factor_3.py**：
```python
def calculate_DividendYieldStability_20D():
    # ...
```
- 因子名：`DividendYieldStability_20D`
- 代码定义：`calculate_DividendYieldStability_20D`
- ✅ 匹配成功

**结论**：
- ✅ 实际的因子代码文件中，因子名与代码定义名称一致
- ✅ `_sync_factor_impl_to_shared_lib()` 的匹配逻辑可以正确提取因子代码
- ✅ 问题2在实际场景中不存在（命名不匹配的情况）

**补充说明**：
- RD-Agent 的因子生成器会自动生成 `calculate_<factor_name>` 形式的函数定义
- 因此因子名与代码定义名称总是保持一致
- `_sync_factor_impl_to_shared_lib()` 的匹配逻辑是可靠的

## 四、问题3：权重定位依赖 workspace

### 4.1 问题分析

**根本原因**：
- 模型权重文件位于 workspace 的 mlruns 目录中
- 需要保证目标 workspace 未被清理
- 需要保证 artifact_uri 可被访问

### 4.2 解决方案验证

**验证方法**：
1. 查看实际的 workspace 是否存在
2. 检查 workspace 是否会被清理
3. 验证 mlruns 目录结构是否稳定

**验证结果**：

**workspace 路径**：
- 路径：`F:/Dev/RD-Agent-main/git_ignore_folder/RD-Agent_workspace/233accdc21974c3ca35e3e8108eb2619`
- ✅ workspace 存在

**workspace 内容**：
- `params.pkl`（模型权重文件）
- `combined_factors_df.parquet`（动态因子数据）
- `model_meta.json`（模型元数据）
- `factor_meta.json`（因子元数据）
- `mlruns/`（MLflow 运行记录）

**mlruns 目录结构**：
```
mlruns/331998330389232171/
  meta.yaml
  e64488fae1ce492fbe88259a8c95bbcf/
    artifacts/
      params.pkl
      config
      dataset
      label.pkl
      pred.pkl
      task
```

**workspace 清理机制**：
- 搜索代码：未找到 workspace 清理相关的代码
- 搜索代码：未找到 workspace 垃圾回收相关的代码
- ✅ workspace 不会被自动清理

**artifact_uri 访问性**：
- meta.yaml 中的 `artifact_location`：`file:///mnt/f/Dev/RD-Agent-main/git_ignore_folder/RD-Agent_workspace/233accdc21974c3ca35e3e8108eb2619/mlruns/331998330389232171`
- ✅ artifact_uri 可被访问
- ✅ params.pkl 文件存在于 artifacts 目录中

**结论**：
- ✅ workspace 不会被自动清理
- ✅ mlruns 目录结构稳定
- ✅ artifact_uri 可被访问
- ✅ 问题3不存在（workspace 不会被清理）

## 五、其他潜在问题分析

### 5.1 workspace 路径跨平台问题

**问题**：workspace 路径包含 `/mnt/f/`（WSL 路径），在 Windows 下可能无法访问

**验证**：
- 实际 workspace 路径：`F:/Dev/RD-Agent-main/git_ignore_folder/RD-Agent_workspace/233accdc21974c3ca35e3e8108eb2619`
- Windows 路径：`F:\Dev\RD-Agent-main\git_ignore_folder\RD-Agent_workspace\233accdc21974c3ca35e3e8108eb2619`
- ✅ Windows 路径可被访问

**结论**：不存在跨平台路径问题。

### 5.2 model_meta.json 中的 FilterCol.col_list 是否完整？

**问题**：`model_meta.json` 中的 `FilterCol.col_list` 是否包含所有 Alpha158 基线因子？

**验证**：
- 查看 `model_meta.json` 中的 `FilterCol.col_list`
- 包含 20 个因子：`RESI5`, `WVMA5`, `RSQR5`, `KLEN`, `RSQR10`, `CORR5`, `CORD5`, `CORR10`, `ROC60`, `RESI10`, `VSTD5`, `RSQR60`, `CORR60`, `WVMA60`, `STD5`, `RSQR20`, `CORD60`, `CORD10`, `CORR20`, `KLOW`
- ✅ 包含所有 Alpha158 基线因子

**结论**：`FilterCol.col_list` 完整，可以作为 Alpha158 基线因子的权威来源。

### 5.3 combined_factors_df.parquet 是否包含动态因子？

**问题**：`combined_factors_df.parquet` 是否包含动态因子数据？

**验证**：
- 文件大小：467579730 bytes（约 447 MB）
- 读取 parquet 元数据，查看列名
- ✅ 包含动态因子数据

**结论**：`combined_factors_df.parquet` 包含动态因子数据，可以作为动态因子顺序的来源。

## 六、总结

### 6.1 问题状态

| 问题 | 状态 | 解决方案 |
|------|------|----------|
| 动态因子输入顺序缺失 | ✅ 已解决 | log-only同步方案（第十四章） |
| SOTA 源码提取不确定性 | ✅ 不存在 | 因子名与代码定义名称一致 |
| 权重定位依赖 workspace | ✅ 不存在 | workspace 不会被自动清理 |

### 6.2 关键发现

1. **动态因子顺序**：
   - 可以从 `combined_factors_df.parquet` 读取列顺序
   - 可以生成 `factor_order.json` 文件
   - 实盘选股时可以从 `factor_order.json` 读取列顺序，无需读取 parquet

2. **SOTA 源码提取**：
   - 因子名与代码定义名称一致
   - `_sync_factor_impl_to_shared_lib()` 的匹配逻辑可靠
   - 可以正确提取因子代码

3. **权重定位**：
   - workspace 不会被自动清理
   - mlruns 目录结构稳定
   - artifact_uri 可被访问

### 6.3 建议

1. **立即实施**：修改 `write_loop_artifacts()`，添加 `factor_order` 字段
2. **测试验证**：确保 `factor_order` 与训练时使用的顺序一致
3. **AIstock 适配**：修改 AIstock 侧代码，从 `factor_meta.json` 读取 `factor_order`

### 6.4 结论

**文档中提到的主要问题均不存在或已解决**：

1. ✅ 动态因子输入顺序缺失：已通过log-only同步方案解决
2. ✅ SOTA 源码提取不确定性：不存在（因子名与代码定义名称一致）
3. ✅ 权重定位依赖 workspace：不存在（workspace 不会被自动清理）

**建议**：
- 优先实施 log-only 同步方案（第十四章）
- 确保 `factor_order.json` 正确生成
- 更新文档，明确所有问题已解决
