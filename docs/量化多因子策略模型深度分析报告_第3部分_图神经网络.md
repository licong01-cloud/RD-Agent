# 量化多因子策略模型深度分析报告 - 第3部分：图神经网络

## 第三部分：计划支持的图神经网络(GNN)

### 8. GCN - 股票关联建模的突破

#### 基本原理与架构

图卷积网络(GCN)将卷积扩展到图结构数据，通过聚合邻居节点信息学习节点表示。

**核心思想**：
- 节点特征 = 自身特征 + 邻居特征加权和
- 多层GCN堆叠，扩大感受野（K-hop邻居）
- 端到端学习图表示

**在量化中的图建模**：
- **节点**：股票、行业、公司
- **边**：供应链关系、行业归属、持股关系、相关性
- **节点特征**：财务指标、价格、技术因子
- **目标**：预测股票收益

#### 量化策略优势分析

**1. 捕获股票间关联（传统模型无法建模！）**
- 供应链传导：上游涨价 → 下游成本上升
- 板块联动：龙头股上涨 → 同板块跟涨
- 持股网络：机构调仓的连锁反应

**2. 行业轮动建模**
- 学习行业间领先-滞后关系
- 例：地产景气 → 建材、家电景气
- 提前布局后续受益行业

**3. 信息扩散建模**
- 公司公告对关联公司影响
- 例：苹果财报 → 苹果供应链股票
- 捕获市场反应不足（mispricing）

**4. 降维与去噪**
- 邻居信息聚合，平滑噪声
- 提升小盘股预测精度（借助关联大盘股信息）

**5. 多层次建模**
- 公司-行业-市场多层图
- 学习微观-中观-宏观联动

#### 劣势与风险

**1. 图构建困难（最大挑战！）**
- 如何定义边？（相关性、供应链、持股？）
- 边权重如何设置？（静态 vs 动态）
- 图结构错误会严重影响效果

**2. 数据获取成本高**
- 供应链数据：需商业数据库（Wind、Bloomberg）
- 持股数据：季度更新，时效性差
- 相关性图：动态变化，计算量大

**3. 过平滑问题(Over-smoothing)**
- 多层GCN后，节点特征趋于一致
- 丧失个性化信息
- 需仔细设计层数（通常2-3层）

**4. 计算复杂度高**
- 图卷积需要邻接矩阵运算
- 全市场4000只股票，邻接矩阵16M元素
- 需稀疏矩阵优化、GPU加速

**5. 可解释性不足**
- 聚合过程复杂，难以解释

**6. 时序建模弱**
- 标准GCN无时序能力
- 需结合LSTM（时空图神经网络）

**7. 过拟合风险**
- 参数量大，金融数据噪声高

#### 收益潜力评估

**预期年化收益**：15%-35%（A股关系增强策略）

**潜力场景**：
- 供应链策略：上下游传导，提前布局
- 板块轮动：行业关联图，捕获联动
- 小盘股增强：借助关联大盘股信息
- 事件驱动：公司公告对产业链影响

**实战案例**：
- 学术论文：HATS模型（图+时序），预测准确率提升10-15%
- 某团队内部测试：GCN+XGBoost，年化收益提升5-8%（相对纯XGBoost）
- **结论**：GCN是**增强工具**，与传统模型结合效果最好

#### 实施建议

**因子类型匹配度**：
- ✅ 最适合：截面因子 + 股票关系图
- ✅ 最适合：行业轮动、供应链策略
- ⚠️ 次适合：纯数值因子（无图优势）
- ❌ 不适合：纯时序因子（用LSTM）

**图构建方案**：

**方案1：基于收益率相关性**
```python
import numpy as np
import pandas as pd

# 计算股票收益率相关性
returns = df.pivot(index='date', columns='stock', values='return')
corr_matrix = returns.corr()

# 阈值化构建边（保留top-k相关）
threshold = 0.5
adj_matrix = (corr_matrix > threshold).astype(int)

# 或者：保留每只股票的top-k邻居
k = 20
adj_matrix = np.zeros_like(corr_matrix)
for i, row in enumerate(corr_matrix.values):
    top_k_indices = np.argsort(row)[-k-1:-1]  # 排除自身
    adj_matrix[i, top_k_indices] = 1
```

**方案2：基于供应链关系**
```python
# 供应链数据（需从外部数据源获取）
supply_chain = pd.read_csv('supply_chain.csv')  
# columns: [supplier, customer, relationship_strength]

import networkx as nx
G = nx.DiGraph()
for _, row in supply_chain.iterrows():
    G.add_edge(
        row['supplier'], 
        row['customer'], 
        weight=row['relationship_strength']
    )

# 转换为邻接矩阵
adj_matrix = nx.to_numpy_array(G)
```

**方案3：基于行业归属**
```python
# 行业归属
industry_df = pd.read_csv('stock_industry.csv')
# columns: [stock, industry]

# 同行业股票互连
from itertools import combinations
edges = []
for industry in industry_df['industry'].unique():
    stocks = industry_df[industry_df['industry']==industry]['stock'].tolist()
    edges.extend(combinations(stocks, 2))

# 构建邻接矩阵
import networkx as nx
G = nx.Graph()
G.add_edges_from(edges)
adj_matrix = nx.to_numpy_array(G)
```

**网络结构实现**：
```python
import torch
import torch.nn as nn
from torch_geometric.nn import GCNConv

class StockGCN(nn.Module):
    def __init__(self, num_features, hidden_dim=64):
        super().__init__()
        self.conv1 = GCNConv(num_features, hidden_dim)
        self.conv2 = GCNConv(hidden_dim, hidden_dim)
        self.fc = nn.Linear(hidden_dim, 1)
        self.dropout = nn.Dropout(0.3)
    
    def forward(self, x, edge_index):
        # x: [num_stocks, num_features]
        # edge_index: [2, num_edges]
        
        x = self.conv1(x, edge_index)
        x = torch.relu(x)
        x = self.dropout(x)
        
        x = self.conv2(x, edge_index)
        x = torch.relu(x)
        x = self.dropout(x)
        
        x = self.fc(x)
        return x.squeeze()

# 训练
model = StockGCN(num_features=50, hidden_dim=64)
optimizer = torch.optim.Adam(model.parameters(), lr=0.001, weight_decay=1e-4)

for epoch in range(100):
    model.train()
    optimizer.zero_grad()
    
    pred = model(node_features, edge_index)
    loss = F.mse_loss(pred, target_returns)
    
    loss.backward()
    optimizer.step()
```

**融合策略（推荐！）**：

**方案1：GCN嵌入 + XGBoost预测**
```python
# 步骤1：GCN提取图嵌入
gcn_model.eval()
with torch.no_grad():
    graph_embeddings = gcn_model.conv2(
        gcn_model.conv1(node_features, edge_index),
        edge_index
    )  # shape: (n_stocks, hidden_dim)

# 步骤2：拼接原始因子
features_combined = np.concatenate([
    graph_embeddings.cpu().numpy(),
    original_factors
], axis=1)

# 步骤3：XGBoost预测
xgb_model = xgb.XGBRegressor()
xgb_model.fit(features_combined, target_returns)
```

**方案2：双模型Ensemble**
```python
# GCN预测
gcn_pred = gcn_model(node_features, edge_index)

# XGBoost预测
xgb_pred = xgb_model.predict(original_factors)

# 加权融合
final_pred = 0.4 * gcn_pred + 0.6 * xgb_pred
```

**训练技巧**：
```python
# 邻接矩阵归一化（防止梯度爆炸）
from torch_geometric.utils import add_self_loops, degree

edge_index, _ = add_self_loops(edge_index, num_nodes=num_stocks)
row, col = edge_index
deg = degree(col, num_stocks, dtype=torch.float)
deg_inv_sqrt = deg.pow(-0.5)
norm = deg_inv_sqrt[row] * deg_inv_sqrt[col]

# 动态图更新（每月/季度）
if current_date.month != last_update_month:
    # 重新计算相关性图
    corr_matrix = returns.tail(252).corr()  # 最近一年
    adj_matrix = build_adjacency_matrix(corr_matrix)
    edge_index = convert_to_edge_index(adj_matrix)
```

**调参优先级**：
1. **图构建方式**（最重要！错误的图导致失败）
2. GCN层数（2-3层最优）
3. Hidden dim
4. Dropout
5. 学习率

**关键建议**：GCN不要单独使用，**必须与传统模型（XGBoost）结合**，作为关系增强模块！

---

### 9. GAT - GCN的升级版，可解释性更强

#### 基本原理与架构

图注意力网络(GAT)是GCN的改进版，引入注意力机制动态学习邻居权重。

**核心创新**：
- **Self-Attention on Graphs**：自动学习每个邻居的重要性
- **Multi-Head Attention**：多头注意力，捕获不同维度关系
- **无需预定义边权重**：从数据中学习

**优于GCN之处**：
- GCN：邻居权重固定（度归一化）
- GAT：邻居权重动态，数据驱动

#### 量化策略优势分析

**继承GCN所有优势，额外优势**：

**1. 动态关系建模**
- 自动学习股票间关系强度
- 无需手工设置边权重
- 适应市场环境变化

**2. 可解释性更强**
- Attention权重可视化
- 识别关键关联股票
- 例：发现供应链瓶颈公司

**3. 对图结构噪声鲁棒**
- 即使图构建有误差，Attention可降低噪声边权重
- 提升稳健性

**4. 多关系建模**
- 多头Attention，每个头学习不同类型关系
- 例：head1学供应链，head2学行业联动，head3学持股关联

**5. 个性化聚合**
- 不同股票聚合不同邻居
- 大盘股可能关注宏观，小盘股关注行业

#### 劣势与风险

**基本同GCN，额外劣势**：

**1. 计算量更大**
- Attention计算复杂度O(N·D²)
- 训练时间是GCN的2-3倍
- 需更强GPU

**2. 参数量更多**
- Multi-Head Attention增加参数
- 过拟合风险更高

**3. 调参更复杂**
- 额外需调整head数量、Attention Dropout

**4. 小图效果不明显**
- 股票数<500时，GAT优势不明显

#### 收益潜力评估

**预期年化收益**：16%-38%（A股关系增强策略）

**优于GCN的场景**：
- 复杂关系图（多种边类型，动态权重更优）
- 大规模图（全市场4000+股票）
- 需要可解释性（Attention可视化）

**对比GCN**：
- 收益提升：1-3%（相对GCN）
- 训练成本：高50%-100%

**实战案例**：
- 学术论文：GAT预测股票走势，准确率比GCN高2-5%
- **结论**：GAT是GCN升级版，效果更好但成本更高

#### 实施建议

**因子类型匹配度**：
- ✅ 同GCN，但更适合复杂关系图

**网络结构实现**：
```python
from torch_geometric.nn import GATConv

class StockGAT(nn.Module):
    def __init__(self, num_features, hidden_dim=64, heads=4):
        super().__init__()
        self.conv1 = GATConv(
            num_features, 
            hidden_dim, 
            heads=heads, 
            dropout=0.3
        )
        self.conv2 = GATConv(
            hidden_dim * heads, 
            hidden_dim, 
            heads=1, 
            dropout=0.3
        )
        self.fc = nn.Linear(hidden_dim, 1)
    
    def forward(self, x, edge_index):
        x = self.conv1(x, edge_index)
        x = torch.elu(x)
        
        x = self.conv2(x, edge_index)
        x = torch.elu(x)
        
        x = self.fc(x)
        return x.squeeze()
```

**Attention权重可视化**：
```python
# 提取Attention权重
model.eval()
with torch.no_grad():
    _, (edge_index, attention_weights) = model.conv1(
        x, edge_index, return_attention_weights=True
    )

# 可视化关键关联
import networkx as nx
import matplotlib.pyplot as plt

G = nx.Graph()
for (src, tgt), weight in zip(edge_index.T, attention_weights):
    if weight > 0.5:  # 只显示高权重边
        G.add_edge(src.item(), tgt.item(), weight=weight.item())

pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', 
        node_size=500, font_size=10)

# 显示边权重
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels)
plt.title('Stock Relationship Graph (Attention Weights)')
plt.show()
```

**GCN vs GAT选择矩阵**：

| 维度 | GCN | GAT |
|------|-----|-----|
| 精度 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 训练速度 | ⭐⭐⭐⭐ | ⭐⭐ |
| 可解释性 | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 对噪声鲁棒性 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 资源需求 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 易用性 | ⭐⭐⭐⭐ | ⭐⭐⭐ |

**选择建议**：
- **选GCN**：快速验证、资源受限、小规模图
- **选GAT**：追求极致性能、需要可解释性、大规模图
- **实用主义**：先GCN，效果好再考虑GAT

---

### 10. GraphSAGE - 大规模图的高效方案

#### 基本原理与架构

GraphSAGE (SAmple and aggreGatE)是针对大规模图设计的GNN，通过邻居采样和聚合解决全图卷积的效率问题。

**核心创新**：
- **邻居采样**：每个节点只采样固定数量邻居
- **多种聚合器**：mean, LSTM, pooling
- **归纳学习**：可处理新节点

**优于GCN/GAT之处**：
- GCN/GAT：全图卷积，大图时效率低
- GraphSAGE：邻居采样，可扩展到百万节点

#### 量化策略优势分析

**继承GCN优势，额外优势**：

**1. 大规模图处理能力**
- 全市场4000+股票，全球股票数万只
- 邻居采样，计算复杂度可控
- 支持实时预测（只需采样局部邻居）

**2. 归纳学习能力**
- 可处理新上市股票（无需重训练）
- 学习聚合函数，泛化到新节点

**3. 灵活的聚合策略**
- Mean聚合：简单高效
- LSTM聚合：考虑邻居顺序
- Pooling聚合：捕获最显著特征

**4. 训练效率高**
- Mini-batch训练，支持大图
- 内存占用可控

#### 劣势与风险

**1. 采样引入随机性**
- 不同采样结果不同
- 需要多次推理取平均

**2. 邻居数量选择困难**
- 采样太少：信息不足
- 采样太多：计算量大

**3. 性能可能不如全图卷积**
- 小图（<1000节点）可能不如GCN
- 损失部分全局信息

**4. 超参数更多**
- 采样数量、聚合器类型、层数

#### 收益潜力评估

**预期年化收益**：15%-36%（A股关系增强策略）

**优于GCN/GAT的场景**：
- 大规模图（全球股票、多市场）
- 需要实时预测（邻居采样快）
- 新股票频繁上市（归纳学习）

**对比GCN/GAT**：
- 收益：与GCN相当，可能略低1-2%
- 训练速度：大图时快5-10倍
- 可扩展性：⭐⭐⭐⭐⭐

#### 实施建议

**因子类型匹配度**：
- ✅ 最适合：大规模截面因子 + 大规模关系图
- ✅ 最适合：多市场策略、全球股票

**网络结构实现**：
```python
from torch_geometric.nn import SAGEConv

class StockGraphSAGE(nn.Module):
    def __init__(self, num_features, hidden_dim=64):
        super().__init__()
        self.conv1 = SAGEConv(num_features, hidden_dim)
        self.conv2 = SAGEConv(hidden_dim, hidden_dim)
        self.fc = nn.Linear(hidden_dim, 1)
        self.dropout = nn.Dropout(0.3)
    
    def forward(self, x, edge_index):
        x = self.conv1(x, edge_index)
        x = torch.relu(x)
        x = self.dropout(x)
        
        x = self.conv2(x, edge_index)
        x = torch.relu(x)
        x = self.dropout(x)
        
        x = self.fc(x)
        return x.squeeze()

# 使用邻居采样器训练
from torch_geometric.loader import NeighborLoader

train_loader = NeighborLoader(
    data,
    num_neighbors=[10, 5],  # 每层采样邻居数
    batch_size=128,
    input_nodes=train_mask,
    shuffle=True
)

for batch in train_loader:
    optimizer.zero_grad()
    pred = model(batch.x, batch.edge_index)
    loss = F.mse_loss(pred[:batch.batch_size], batch.y[:batch.batch_size])
    loss.backward()
    optimizer.step()
```

**GCN vs GAT vs GraphSAGE选择**：

| 维度 | GCN | GAT | GraphSAGE |
|------|-----|-----|-----------|
| 小图(<1000节点) | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 大图(>5000节点) | ⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ |
| 精度 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 训练速度(大图) | ⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ |
| 可解释性 | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 归纳学习 | ❌ | ❌ | ⭐⭐⭐⭐⭐ |

**选择建议**：
- **A股单市场**：GCN或GAT（节点数适中）
- **全球多市场**：GraphSAGE（大规模图）
- **新股频繁上市**：GraphSAGE（归纳学习）

---

## 图神经网络总结

### 真实量化交易适用性评估

| 模型 | 适用策略 | 收益潜力 | 风险等级 | 推荐指数 |
|------|----------|----------|----------|----------|
| GCN | 供应链、板块轮动 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| GAT | 同GCN，但需可解释性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| GraphSAGE | 大规模图、多市场 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

### 关键建议

**1. GNN是增量收益工具，非主力**
- GNN单独使用效果有限
- **必须与树模型（XGBoost）结合**
- 提升幅度通常5-10%

**2. 图构建是核心**
- 图构建质量决定80%效果
- 建议多图融合（相关性+供应链+行业）
- 动态更新图结构（每月/季度）

**3. 数据是瓶颈**
- 供应链数据获取困难且昂贵
- 持股数据时效性差
- 相关性图计算量大

**4. 实施路径**
- **阶段1**：XGBoost baseline
- **阶段2**：构建相关性图（最容易）
- **阶段3**：GCN提取图嵌入，拼接原始因子，XGBoost预测
- **阶段4**：评估收益提升，决定是否采用更复杂图（供应链）

**5. 适用团队**
- 有图神经网络经验
- 有数据资源（供应链、持股等）
- 有GPU资源
- **否则，专注于树模型优化**

**6. ROI评估**
- GNN开发成本高（数据+算力+人力）
- 收益提升可能有限（5-10%）
- 需仔细评估投入产出比
