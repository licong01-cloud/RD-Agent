# 分阶段执行因子演进和模型演进方案分析

## 实施日期
2026-01-14

## 1. 问题提出

用户提出了一个关键问题：

> "是否可以分成两个任务，第一个任务执行因子演进，得出SOTA因子后，第二个任务在第一个任务基础上只做模型演进，基于第一个任务的sota因子和alpha22因子，做模型演进，分析这个流程是否可以实现，是否不需要修改代码"

### 1.1 核心问题

**问题1：是否可以分成两个任务？**
- 第一个任务：执行因子演进，得出SOTA因子
- 第二个任务：基于第一个任务的SOTA因子和Alpha22因子，只做模型演进

**问题2：这个流程是否可以实现？**
- RD-Agent是否支持分阶段执行？
- 第二个任务能否访问第一个任务的SOTA因子？

**问题3：是否不需要修改代码？**
- 是否可以通过配置实现？
- 还是需要修改代码？

## 2. RD-Agent任务执行机制分析

### 2.1 based_experiments机制

从代码分析来看，RD-Agent使用`based_experiments`机制来传递SOTA因子：

**factor_proposal.py (第112-114行)**：
```python
exp.based_experiments = [QlibFactorExperiment(sub_tasks=[])] + [
    t[0] for t in trace.hist if t[1] and isinstance(t[0], FactorExperiment)
]
```

**model_proposal.py (第158行)**：
```python
exp.based_experiments = [t[0] for t in trace.hist if t[1] and isinstance(t[0], ModelExperiment)]
```

**关键发现**：
- `based_experiments`是从`trace.hist`中提取的
- `trace.hist`包含了所有的实验历史
- 每个实验执行后，会被添加到`trace.hist`中

### 2.2 SOTA因子的使用

**model_runner.py (第156-165行)**：
```python
exist_sota_factor_exp = False
if exp.based_experiments:
    SOTA_factor = None
    # Filter and retain only QlibFactorExperiment instances
    sota_factor_experiments_list = [
        base_exp for base_exp in exp.based_experiments if isinstance(base_exp, QlibFactorExperiment)
    ]
    # 修改：降低SOTA因子使用条件，从>1改为>=1，确保只要有SOTA因子就使用
    if len(sota_factor_experiments_list) >= 1:
        logger.info(f"SOTA factor processing ...")
        SOTA_factor = process_factor_data(sota_factor_experiments_list)
```

**关键发现**：
- SOTA因子是从`exp.based_experiments`中提取的
- `based_experiments`包含了之前的所有实验
- 如果`based_experiments`为空，则无法使用SOTA因子

### 2.3 Trace.hist机制

**core/proposal.py (第131-163行)**：
```python
class Trace(Generic[ASpecificScen, ASpecificKB]):
    NodeType = tuple[Experiment, ExperimentFeedback]  # Define NodeType as a new type representing the tuple
    NEW_ROOT: tuple = ()

    def __init__(self, scen: ASpecificScen, knowledge_base: ASpecificKB | None = None) -> None:
        self.scen: ASpecificScen = scen

        # BEGIN: graph structure -------------------------
        self.hist: list[Trace.NodeType] = (
            []
        )  # List of tuples containing experiments and their feedback, organized over time.
        self.dag_parent: list[tuple[int, ...]] = []  # List of tuples representing parent indices in the DAG structure.
        # ...
```

**关键发现**：
- `Trace`类维护了一个`hist`列表
- `hist`包含了所有的实验历史
- 每个实验执行后，会被添加到`trace.hist`中

## 3. 分阶段执行的可行性分析

### 3.1 当前RD-Agent的任务执行流程

**单任务执行流程**：
```
开始
  ↓
创建Trace对象
  ↓
执行因子演进
  ↓
添加到trace.hist
  ↓
执行模型演进
  ↓
添加到trace.hist
  ↓
结束
```

**关键点**：
- 所有实验都在同一个`Trace`对象中
- `trace.hist`包含了所有的实验历史
- `based_experiments`是从`trace.hist`中提取的

### 3.2 分阶段执行的问题

**问题1：第二个任务无法访问第一个任务的trace.hist**

如果分成两个任务：
- 第一个任务：创建Trace对象，执行因子演进，添加到trace.hist
- 第二个任务：创建新的Trace对象，执行模型演进

**问题**：
- 第二个任务的`Trace`对象是新的
- 第二个任务的`trace.hist`是空的
- 第二个任务的`based_experiments`是空的
- 第二个任务无法访问第一个任务的SOTA因子

**问题2：based_experiments的传递**

从代码来看：
- `based_experiments`是从`trace.hist`中提取的
- 如果`trace.hist`是空的，则`based_experiments`也是空的
- 如果`based_experiments`是空的，则无法使用SOTA因子

**问题3：Trace对象的持久化**

从代码来看：
- `Trace`对象没有被持久化
- 每次执行任务都会创建新的`Trace`对象
- 无法在不同任务间共享`Trace`对象

### 3.3 分阶段执行的解决方案

#### 方案1：修改代码，支持Trace对象的持久化

**实现步骤**：
1. 在第一个任务执行完后，保存`Trace`对象到文件
2. 在第二个任务执行前，从文件加载`Trace`对象
3. 使用加载的`Trace`对象执行第二个任务

**优点**：
- ✅ 可以实现分阶段执行
- ✅ 第二个任务可以访问第一个任务的SOTA因子

**缺点**：
- ❌ 需要修改代码
- ❌ 需要实现`Trace`对象的序列化和反序列化
- ❌ 需要修改任务执行流程

**工作量**：
- 修改代码量：约200-300行
- 实施时间：3-5天

#### 方案2：修改代码，支持based_experiments的手动传递

**实现步骤**：
1. 在第一个任务执行完后，保存SOTA因子到文件
2. 在第二个任务执行前，从文件加载SOTA因子
3. 手动设置`based_experiments`

**优点**：
- ✅ 可以实现分阶段执行
- ✅ 第二个任务可以访问第一个任务的SOTA因子
- ✅ 只需修改少量代码

**缺点**：
- ❌ 需要修改代码
- ❌ 需要实现SOTA因子的保存和加载

**工作量**：
- 修改代码量：约100-150行
- 实施时间：2-3天

#### 方案3：不修改代码，使用单任务执行

**实现步骤**：
1. 使用环境变量控制任务类型
2. 第一个任务：只执行因子演进
3. 第二个任务：只执行模型演进
4. 通过环境变量控制跳过某些步骤

**优点**：
- ✅ 不需要修改代码
- ✅ 实现简单

**缺点**：
- ❌ 不是真正的分阶段执行
- ❌ 需要手动控制任务类型
- ❌ 无法实现真正的分离

**工作量**：
- 修改代码量：约50行
- 实施时间：1天

## 4. 推荐方案

### 4.1 方案对比

| 方案 | 是否需要修改代码 | 工作量 | 是否真正的分阶段 | 推荐度 |
|-----|----------------|-------|----------------|-------|
| 方案1：Trace持久化 | ✅ 需要 | 200-300行，3-5天 | ✅ 是 | ⭐⭐⭐ |
| 方案2：based_experiments手动传递 | ✅ 需要 | 100-150行，2-3天 | ✅ 是 | ⭐⭐⭐⭐ |
| 方案3：单任务执行 | ✅ 需要 | 50行，1天 | ❌ 否 | ⭐⭐ |

### 4.2 推荐方案：方案2 - based_experiments手动传递

**推荐理由**：
1. ✅ 可以实现真正的分阶段执行
2. ✅ 第二个任务可以访问第一个任务的SOTA因子
3. ✅ 只需修改少量代码
4. ✅ 实施简单，易于回退

**实施步骤**：

**第一步：修改factor_runner.py，保存SOTA因子**
```python
# 在factor_runner.py的develop方法中，添加保存SOTA因子的逻辑
def develop(self, exp: QlibFactorExperiment) -> QlibFactorExperiment:
    # ... 现有代码 ...
    
    # 保存SOTA因子到文件
    save_sota_factors = os.getenv("SAVE_SOTA_FACTORS", "false") == "true"
    if save_sota_factors and SOTA_factor is not None and not SOTA_factor.empty:
        sota_factors_path = Path(os.getenv("SOTA_FACTORS_PATH", "./sota_factors.parquet"))
        SOTA_factor.to_parquet(sota_factors_path, engine="pyarrow")
        logger.info(f"SOTA factors saved to {sota_factors_path}")
    
    # ... 现有代码 ...
```

**第二步：修改model_runner.py，加载SOTA因子**
```python
# 在model_runner.py的develop方法中，添加加载SOTA因子的逻辑
def develop(self, exp: QlibModelExperiment) -> QlibModelExperiment:
    # 加载SOTA因子
    load_sota_factors = os.getenv("LOAD_SOTA_FACTORS", "false") == "true"
    if load_sota_factors:
        sota_factors_path = Path(os.getenv("SOTA_FACTORS_PATH", "./sota_factors.parquet"))
        if sota_factors_path.exists():
            SOTA_factor = pd.read_parquet(sota_factors_path, engine="pyarrow")
            logger.info(f"SOTA factors loaded from {sota_factors_path}")
            
            # 创建based_experiments
            sota_factor_exp = QlibFactorExperiment(sub_tasks=[])
            sota_factor_exp.result = {"IC": 0.0}  # 设置一个虚拟的结果
            exp.based_experiments = [sota_factor_exp]
    
    # ... 现有代码 ...
```

**第三步：环境变量配置**
```env
# 第一个任务：因子演进
SAVE_SOTA_FACTORS=true
SOTA_FACTORS_PATH=./sota_factors.parquet
LOAD_SOTA_FACTORS=false

# 第二个任务：模型演进
SAVE_SOTA_FACTORS=false
SOTA_FACTORS_PATH=./sota_factors.parquet
LOAD_SOTA_FACTORS=true
USE_ALPHA_FACTORS=true
```

**第四步：执行两个任务**
```bash
# 第一个任务：因子演进
export SAVE_SOTA_FACTORS=true
export LOAD_SOTA_FACTORS=false
python run_factor_evolution.py

# 第二个任务：模型演进
export SAVE_SOTA_FACTORS=false
export LOAD_SOTA_FACTORS=true
export USE_ALPHA_FACTORS=true
python run_model_evolution.py
```

## 5. 结论

### 5.1 回答用户的问题

**问题1：是否可以分成两个任务？**
- ✅ 可以，但需要修改代码

**问题2：这个流程是否可以实现？**
- ✅ 可以实现，但需要修改代码

**问题3：是否不需要修改代码？**
- ❌ 需要修改代码

### 5.2 最终建议

**推荐采用方案2：based_experiments手动传递**

**理由**：
1. ✅ 可以实现真正的分阶段执行
2. ✅ 第二个任务可以访问第一个任务的SOTA因子
3. ✅ 只需修改少量代码（约100-150行）
4. ✅ 实施简单，易于回退

**实施时间**：
- 修改代码：2-3天
- 测试验证：1-2天
- 总计：3-5天

**预期效果**：
- ✅ 可以实现分阶段执行
- ✅ 第二个任务可以访问第一个任务的SOTA因子
- ✅ 可以基于SOTA因子和Alpha22因子进行模型演进

## 6. 附录

### 6.1 环境变量配置示例

```env
# 第一个任务：因子演进
SAVE_SOTA_FACTORS=true
SOTA_FACTORS_PATH=./sota_factors.parquet
LOAD_SOTA_FACTORS=false

# 第二个任务：模型演进
SAVE_SOTA_FACTORS=false
SOTA_FACTORS_PATH=./sota_factors.parquet
LOAD_SOTA_FACTORS=true
USE_ALPHA_FACTORS=true
```

### 6.2 回滚方法

如果需要回退到原始行为，只需设置环境变量：

```bash
# 回退到原始行为
export SAVE_SOTA_FACTORS=false
export LOAD_SOTA_FACTORS=false
```

### 6.3 监控指标

**第一个任务监控指标**：
- SOTA因子数量
- SOTA因子IC
- 保存路径

**第二个任务监控指标**：
- 加载的SOTA因子数量
- 模型IC
- 模型类型

## 7. 版本历史

| 版本 | 日期 | 说明 |
|-----|------|------|
| v1.0 | 2026-01-14 | 初始版本，分析分阶段执行的可行性和实施方案 |
