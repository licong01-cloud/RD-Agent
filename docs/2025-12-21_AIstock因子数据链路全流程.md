# 2025-12-21 AIstock 因子数据链路全流程（数据准备→静态因子→合并→schema→RD-Agent 消费）

> 目标：把 AIstock 数据准备、RD-Agent 侧静态因子生成/合并、schema 生成与校验、以及在 Qlib/RD-Agent 场景中的消费关系串起来，形成可复现的端到端流程。
>
> 约定：你当前已将 AIstock 全量迁移到 `F:\Dev\AIstock\`，不再使用 `C:\Users\lc999\NewAIstock\AIstock\`。

---

## 0. 目录与关键约定（必须统一）

### 0.1 AIstock 数据根目录（统一到 F 盘）

- Snapshot（HDF5）根目录（Windows）：
  - `F:/Dev/AIstock/qlib_snapshots/<snapshot_id>/`
- Qlib bin 根目录（Windows）：
  - `F:/Dev/AIstock/qlib_bin/`
- Qlib csv 根目录（Windows）：
  - `F:/Dev/AIstock/qlib_csv/`
- AIstock factors 根目录（Windows）：
  - `F:/Dev/AIstock/factors/`

> 说明：RD-Agent 在 WSL 下运行时，Windows 路径通常应对应为 `/mnt/f/Dev/AIstock/...`。

### 0.2 关键环境变量（.env）

建议（你仓库当前 `.env` 已有这些值或同类项）：

- `QLIB_DATA_PATH=/mnt/f/Dev/AIstock/qlib_snapshots/<snapshot_id>`
- `AIstock_SNAPSHOT_ROOT=/mnt/f/Dev/AIstock/qlib_snapshots/<snapshot_id>`
- `AISTOCK_FACTORS_ROOT=/mnt/f/Dev/AIstock/factors`
- `AISTOCK_DATA_GOVERNANCE_DIR=/mnt/f/Dev/AIstock/data_governance`

以及 WSL 调度相关：

- `QLIB_RDAGENT_ROOT_WIN=F:/dev/RD-Agent-main`
- `QLIB_RDAGENT_ROOT_WSL=/mnt/f/dev/RD-Agent-main`
- `QLIB_BIN_ROOT_WIN=F:/Dev/AIstock/qlib_bin`
- `QLIB_CSV_ROOT_WIN=F:/Dev/AIstock/qlib_csv`

---

## 1. 数据准备（AIstock 侧产出）

### 1.1 Snapshot（HDF5）导出

AIstock 负责导出基础面板（通常在 snapshot 目录内）：

- `daily_pv.h5`：日线价量
- `moneyflow.h5`：资金流（`mf_*`）
- `daily_basic.h5`：每日指标（`db_*`）
- `instruments/all.txt`：标的与起止
- `calendars/day.txt`：交易日历（如存在）

这些文件用于：

- RD-Agent/CoSTEER 在 pandas 层计算自定义因子；
- 以及后续合并为静态因子 bundle（`static_factors.parquet`）。

### 1.2 Qlib bin（可选，但用于标准 qrun/backtest）

如果要跑 Qlib 的标准训练/回测（Alpha158、DatasetH 等），需要 AIstock 导出 Qlib bin：

- `F:/Dev/AIstock/qlib_bin/<bin_id>/...`

这一步与“静态因子 bundle”是并行链路：

- bin：给 Qlib 作为行情/回测底座
- HDF5/Parquet：给因子研发（CoSTEER/pandas）与 feature 扩展

---

## 2. 预计算因子生成（RD-Agent 仓库脚本）

本阶段输出到 `AISTOCK_FACTORS_ROOT`（例如 `/mnt/f/Dev/AIstock/factors`）下。

### 2.1 daily_basic 预计算因子

- 脚本：`precompute_daily_basic_factors.py`
- 输入：`<snapshot_root>/daily_basic.h5`
- 输出（目录/文件名示例）：
  - `<factors_root>/daily_basic_factors/result.h5`
  - `<factors_root>/daily_basic_factors/result.pkl`
  - `<factors_root>/daily_basic_factors/result.parquet`

### 2.2 moneyflow 预计算因子

- 脚本：`tools/precompute_moneyflow_factors.py`
- 输入：
  - `<snapshot_root>/moneyflow.h5`
  - `<snapshot_root>/daily_pv.h5`（用于 amount/volume 分母）
- 输出：
  - `<factors_root>/moneyflow_factors/result.pkl`

> 注意：该脚本包含 Windows→WSL 路径映射逻辑（`C:/...`→`/mnt/c/...` 这类）。在迁移到 F 盘后，应确保输入路径以 `F:/...` 或 `/mnt/f/...` 形式传入。

### 2.3 AE 重构误差因子（可选）

- 因子脚本：`factor_ae_recon_error_10d.py`
- 转换脚本：`convert_ae_factor_h5_to_parquet.py`
- 输出可被后续合并进静态 bundle。

---

## 3. 静态因子合并（static_factors.parquet + schema）

### 3.1 合并脚本

- 脚本：`tools/generate_static_factors_bundle.py`
- 输入：
  - snapshot：`daily_basic.h5`、`moneyflow.h5`、可选 `daily_pv.h5`
  - 可选预计算表（存在则合并）：
    - `<factors_root>/daily_basic_factors/result.pkl`
    - `<factors_root>/moneyflow_factors/result.pkl`
    - `<factors_root>/ae_recon_error_10d/result.pkl`
    - `<factors_root>/combined_static_factors.parquet`
  - 可选字段含义映射：`aistock_field_map.csv`（见第 3.3）

- 输出（仓库侧）：
  - `git_ignore_folder/factor_implementation_source_data/static_factors.parquet`
  - `git_ignore_folder/factor_implementation_source_data/static_factors_schema.json`
  - `git_ignore_folder/factor_implementation_source_data/static_factors_schema.csv`

并且按 `20251214_因子演进_debug_static_factors_rolling_retry备忘录.md` 的修复点：

- schema 也会同步写入 debug 目录：
  - `git_ignore_folder/factor_implementation_source_data_debug/static_factors_schema.json|csv`

### 3.2 rolling 派生列与 fallback

该脚本会从 moneyflow 原始字段派生一组更稳定的 `mf_*` 字段，并包含 5D/20D rolling 聚合。

当 `moneyflow_raw` 缺少分档字段导致派生为空时，会从可选表（尤其 `combined_static_factors.parquet`）中筛选 `mf_` 列作为 fallback 再尝试派生。

### 3.3 字段含义映射（AIstock_field_map_export_spec）

- 文档：`docs/AIstock_field_map_export_spec.md`
- AIstock 侧导出：`aistock_field_map.csv`（建议固定在 `.../metadata/` 下）
- RD-Agent 侧在执行 `generate_static_factors_bundle.py` 时通过 `--field-map` 指向该文件，从而把 `meaning_cn/unit/source_table` 写进 schema。

---

## 4. 因子 schema 生成（factor set schema）

### 4.1 factor set schema（daily_basic_factors / capital_flow_daily 等）

- 脚本：`tools/generate_factor_schemas.py`
- 输入：
  - `--factors-root <AISTOCK_FACTORS_ROOT>`（必填）
  - `--out-dir-governance <AISTOCK_DATA_GOVERNANCE_DIR>`（必填）
- 输出：
  - `<factors_root>/<factor_set>/metadata/<factor_set>_schema.json|csv`
  - `<out_dir_governance>/schemas/factors/<factor_set>_schema.json|csv`

> 注意：`tools/generate_factor_schemas.py` 内置了 `capital_flow_daily` 这个 factor set 名，但仓库当前未发现同名“产出 result.pkl/h5”的脚本入口；它更像是一个“治理/校验侧的预期集合名”。

---

## 5. 校验（schema 与产物一致性）

- 脚本：`tools/verify_factor_outputs.py`
- 输入：
  - `--factors-root <AISTOCK_FACTORS_ROOT>`
  - `--schema-dir <.../schemas/factors>`
  - `--factor-sets`（默认包含 `daily_basic_factors,capital_flow_daily`）
- 检查：
  - `<factors_root>/<factor_set>/result.pkl` 是否存在
  - `result.pkl` 的列是否与 `<factor_set>_schema.json` 一致

---

## 6. RD-Agent/Qlib 场景如何消费这些产物

### 6.1 因子运行数据目录准备

- 逻辑入口：`rdagent/scenarios/qlib/experiment/utils.py` 的 `generate_data_folder_from_qlib()`
- 优先复制：
  - repo 侧生成的 `static_factors.parquet` 与 schema（csv/json）到因子执行目录（含 debug）
- fallback：
  - 从 `AISTOCK_FACTORS_ROOT` 下的 `combined_static_factors.parquet` 等候选文件取静态表

### 6.2 LLM/CoSTEER 的“列名白名单”

- prompt/流程要求：因子实现必须以 `static_factors_schema.csv/json` 为白名单，禁止 LLM 编造列名。
- 参见：`docs/20251214_因子演进_debug_static_factors_rolling_retry备忘录.md`

---

## 7. 为什么会出现“写错目录”（F:\Dev\RD-Agent-main\C\Users\...）？

### 7.1 事实时间线（来自文件系统时间戳）

异常目录（真实存在）：

- `F:\Dev\RD-Agent-main\C\Users\lc999\NewAIstock\AIstock\factors\capital_flow_daily\`

时间戳（本机读取）：

- 目录创建时间：`2025-12-17 13:08:56`
- 目录修改时间：`2025-12-17 13:08:56`
- 目录内文件：
  - `result.h5` 修改时间：`2025-12-10 01:29:00`
  - `result.pkl` 修改时间：`2025-12-10 01:29:00`

### 7.2 根因判断（高置信）

- 目录名中出现 `C`（注意不是标准 `C:`），说明某次执行时传入的路径字符串里，盘符冒号被替换成了异常字符（复制粘贴/编码/字体替换常见）。
- 对 Python `Path` 来说，`C/...` 会被当成“普通相对路径片段”，从而在当前工作目录（repo 根）下被 `mkdir(parents=True)` 创建出来。
- 目录创建时间（12/17）晚于文件修改时间（12/10），说明：
  - `result.h5/result.pkl` 很可能先在其它位置生成；
  - 后续某次操作把它们复制/移动到了这个异常目录下（或解压/同步工具写入）。

> 结论：更像是“运行参数/路径字符串异常 + 脚本按参数创建目录”的组合问题，而不是脚本主动拼错路径。

### 7.3 与“C 盘迁移到 F 盘”的关系

你已经明确：`C:\Users\lc999\NewAIstock\AIstock` 已不用，全部迁移到 `F:\Dev\AIstock`。

因此后续应统一：

- 命令行参数用 `F:/Dev/AIstock/...`（Windows）或 `/mnt/f/Dev/AIstock/...`（WSL）
- `.env` 中也统一指向 `/mnt/f/Dev/AIstock/...`

并避免从旧文档/历史命令直接复制 `C:/Users/...` 路径（更避免复制后冒号被替换）。

---

## 8. 建议的“最小可复现”全流程命令（以 F 盘为准）

> 说明：以下是命令示例，用于说明顺序与参数来源；实际执行请根据你环境（Windows/WSL/conda）调整。

1) 生成 daily_basic_factors：

- 输入来自 snapshot；输出到 factors root。

2) 生成 moneyflow_factors：

- 运行 `tools/precompute_moneyflow_factors.py`
- `snapshot_root` 与 `factors_root` 来自 env（建议）或参数（如你自行包装脚本）。

3) 合并生成 static_factors bundle：

- 运行 `tools/generate_static_factors_bundle.py`
- 建议显式传入：
  - `--snapshot-root /mnt/f/Dev/AIstock/qlib_snapshots/<snapshot_id>`
  - `--aistock-factors-root /mnt/f/Dev/AIstock/factors`
  - 可选：`--field-map /mnt/f/Dev/AIstock/metadata/aistock_field_map.csv`

4) 生成 factor schemas：

- `python tools/generate_factor_schemas.py --factors-root F:/Dev/AIstock/factors --out-dir-governance F:/Dev/AIstock/data_governance`

5) 校验 factor outputs：

- `python tools/verify_factor_outputs.py --factors-root F:/Dev/AIstock/factors --schema-dir F:/Dev/AIstock/data_governance/schemas/factors`

---

## 9. 关联文档（现有）

- `docs/AIstock_Qlib_数据集使用备忘录.md`

---

## 10. 小结：数据服务层对 RD-Agent/Qlib 的标准视图约定

> 本节是对顶层设计中“数据服务层”部分的落地补充，约束后续开发不要在 RD-Agent/Qlib 内直接耦合具体数据源（miniQMT/TDX/tushare/timescaledb 等），而是统一通过 AIstock 的标准视图消费数据。

### 10.1 面向 RD-Agent/因子研发的标准视图

RD-Agent/CoSTEER 的因子脚本、静态因子生成与 schema 工具，应只依赖以下**标准化视图**：

- **Snapshot 视图**（本文件第 1 节已描述）：
  - `daily_pv.h5`：统一 schema 的日线价量（`$open/$high/$low/$close/$volume/$amount/$factor` 等）；
  - `moneyflow.h5`：统一 schema 的资金流字段（`mf_*`）；
  - `daily_basic.h5`：统一的每日指标字段（`db_*`）；
  - `instruments/all.txt`、`calendars/day.txt`：标的与交易日历。
- **静态因子视图**：
  - `static_factors.parquet`：统一索引（MultiIndex(datetime,instrument)）+ 统一列命名的静态因子表；
  - 各种 `result.h5/result.pkl/result.parquet`：均按统一规范输出，多用于中间产物与调试。

> 约束：
>
> - 因子脚本与 RD-Agent 代码**只能面向这些“标准文件/字段”写逻辑**，禁止在内部直接引用“来自 miniQMT 的某字段”或“来自 TDX 的某字段名”。
> - miniQMT/TDX/tushare/timescaledb 之间的字段/频率/复权差异，必须在 AIstock 数据服务层内部解决。

### 10.2 面向 Qlib/回测的标准视图

Qlib/回测（包括 Alpha158、DatasetH/TSDatasetH 等）应只依赖：

- **Qlib bin**：
  - `F:/Dev/AIstock/qlib_bin/<bin_id>/...` 按 Qlib 官方规范组织的行情/指数/基准数据；
  - AIstock 数据服务层负责将底层数据源（miniQMT/TDX/tushare/timescaledb）转换为规范的 bin 结构。
- **Alpha158/handler 需要的字段定义**：
  - 在数据服务层内，通过统一的 field_map 将底层字段映射为 `$open/$close/...` 等 Qlib 期望的字段；
  - Qlib YAML 只需引用这些标准字段，而不感知具体数据源是谁。

> 约束：
>
> - Qlib 配置（YAML）只依赖 AIstock 提供的 bin/field_map，不应硬编码“TDX 字段名”或“tushare 专用字段”。

### 10.3 数据服务层的推荐架构形态

在工程实现上，数据服务层推荐分阶段演进，而不是一开始就做成复杂的分布式系统：

1. **Phase A：AIstock 后端中的统一数据访问模块（推荐起点）**
   - 形态：
     - 可以是 AIstock 后端中的一个 Python 包/模块（如 `aistock.data_service`），也可以是同一进程内暴露的一组函数/类；
   - 职责：
     - 封装对 miniQMT/TDX/tushare/timescaledb 的访问；
     - 提供“按规范返回 DataFrame / ndarray / qlib bin 目录”的接口；
     - 把字段名/频率/复权/异常值处理统一收口在这里。
   - 消费方式：
     - RD-Agent 的预计算脚本/静态因子脚本可以通过命令行参数/环境变量调用该模块产出的标准文件；
     - Qlib 数据准备脚本也从该模块获取原始数据再落地为 bin/csv。

2. **Phase B：演进为独立数据服务（HTTP/gRPC 等，可选）**
   - 在负载、团队协作或语言多样性需要时，再将数据服务模块抽取为独立进程（如一个 `data-service` 服务），对外暴露 HTTP/gRPC API：
     - `GET /qlib/bin`, `GET /snapshot/daily_pv`, `GET /realtime/quotes` 等；
   - RD-Agent、Qlib 准备脚本、模拟盘/实盘模块通过 API 访问数据，而不再直接访问底层库。

3. **Phase C：按需引入缓存（如 Redis）与队列（如 MQ/Kafka）（可选）**
   - 当实时行情/回测请求较多时：
     - 可以在数据服务层内部用 Redis 缓存热点数据（如近期行情、常用因子片段）；
   - 当需要实时流式处理（如 tick/逐笔）时：
     - 可在数据服务层与 miniQMT 之间引入消息队列（MQ/Kafka）作为缓冲与解耦。
   - 这些均属于**数据服务层内部的实现细节**，对 RD-Agent/Qlib 来说仍然是透明的。

> 总体建议：
>
> - **短期内以“AIstock 后端中的统一数据访问模块”为主即可，无需一开始就上 Redis/MQ 或重型微服务。**
> - 只要先把“标准视图 + 字段契约”设计好，后续无论是否拆成独立服务/引入缓存，都不会影响 RD-Agent/Qlib 的调用方式。

- `docs/rdagent_precomputed_factors_cn.md`
- `docs/AIstock_field_map_export_spec.md`
- `docs/20251214_因子演进_debug_static_factors_rolling_retry备忘录.md`
- `docs/RD-Agent_AIstock_Qlib_备忘录.md`
