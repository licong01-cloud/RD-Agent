# 因子顺序获取方案分析

## 一、问题定义

根据《模型权重文件定位方案_v2.md》第12节的分析，当前存在以下核心问题：

1. **动态因子输入顺序缺失**：无法从 log/session 或 model_meta.json 恢复动态因子顺序；若禁止读取 combined_factors_df.parquet，则无法严格对齐训练输入顺序。
2. **SOTA 源码提取不确定性**：`_sync_factor_impl_to_shared_lib()` 依赖"因子名与代码定义名称一致"，对命名不匹配场景无保证。
3. **权重定位依赖 workspace**：需要保证目标 workspace 未被清理，且 artifact_uri 可被访问。

## 二、源码分析

### 2.1 动态因子加载机制

**文件位置**：`rdagent/scenarios/qlib/experiment/custom_loaders.py`

```python
class CombinedAlpha158DynamicFactorsLoader:
    def __init__(
        self,
        alpha158_config: dict,
        dynamic_path: str,
        join: str = "left",
        min_dynamic_non_nan_ratio: float = 0.01,
        min_instrument_overlap_ratio: float = 0.8,
        enforce_instrument_format: bool = True,
    ) -> None:
        self.alpha_loader = Alpha158DL(config=alpha158_config)
        self.dynamic_loader = StaticDataLoader(config=dynamic_path)
        # ...
```

**关键发现**：
- 动态因子通过 `dynamic_path=combined_factors_df.parquet` 加载
- Alpha158 基线因子通过 `alpha158_config` 配置
- 最终通过 `pd.concat([df_alpha, df_dynamic], axis=1, join=self.join)` 合并

**结论**：
- **Alpha 基线顺序**：可从 `alpha158_config.feature` 列表获取
- **动态 SOTA 因子顺序**：仅存在于 `combined_factors_df.parquet` 的列顺序中
- **合并后顺序**：`[Alpha158列] + [动态因子列]`

### 2.2 factor_meta.json 写入逻辑

**文件位置**：`rdagent/utils/artifacts_writer.py:write_loop_artifacts()`

```python
# 2. 增强逻辑：从 combined_factors_df.parquet 中提取全量因子名 (确保 Alpha158/360 不缺失)
if combined_factors.exists():
    try:
        import pyarrow.parquet as pq
        meta = pq.read_metadata(combined_factors)
        all_cols = meta.schema.names
        
        factor_meta_payload = factor_meta_payload or {
            "version": "v1",
            "task_run_id": task_run_id,
            "loop_id": loop_id,
            "created_at_utc": datetime.now(timezone.utc).isoformat(),
            "factors": []
        }
        
        existing_names = {f.get("name") for f in factor_meta_payload.get("factors", [])}
        for name in all_cols:
            if name in ("datetime", "instrument", "index", "level_0", "level_1"):
                continue
            if name not in existing_names:
                is_alpha = any(x in name.lower() for x in ["alpha158", "alpha360"])
                factor_meta_payload["factors"].append({
                    "name": name,
                    "source": "sota" if is_alpha else "rdagent_generated",
                    # ...
                })
```

**关键发现**：
- `factor_meta.json` 中包含所有因子名称（从 parquet 列名提取）
- **但未包含因子顺序信息**
- 因子顺序丢失，仅保留名称列表

### 2.3 model_meta.json 提取逻辑

**文件位置**：`rdagent/utils/artifacts_writer.py:_extract_model_metadata_from_workspace()`

```python
def _extract_model_metadata_from_workspace(ws_root: Path) -> dict[str, Any]:
    """Extract detailed model metadata (conf, dataset, feature schema) from workspace."""
    model_metadata = {
        "model_type": None,
        "model_conf": None,
        "dataset_conf": None,
        "feature_schema": None,
        "preprocess_config": None,
    }
    # ...
    # 3. Extract feature_schema (multiple locations)
    if model_metadata["feature_schema"] is None:
        # Case A: data_handler_config in base
        dh_conf = base.get("data_handler_config")
        if isinstance(dh_conf, dict):
            model_metadata["feature_schema"] = dh_conf.get("feature")
```

**关键发现**：
- `model_meta.json` 包含 `feature_schema` 字段
- `feature_schema` 来自 YAML 配置中的 `data_handler_config.feature`
- **但 `feature_schema` 仅包含 Alpha158 基线因子列表，不包含动态 SOTA 因子顺序**

## 三、核心问题分析

### 3.1 动态因子顺序为何无法恢复？

**根本原因**：
1. RD-Agent 训练时，动态因子通过 `CombinedAlpha158DynamicFactorsLoader` 加载
2. 该 loader 使用 `pd.concat([df_alpha, df_dynamic], axis=1)` 合并
3. 合并后的列顺序为：`[Alpha158列] + [动态因子列]`
4. **动态因子的列顺序由 `combined_factors_df.parquet` 的列顺序决定**
5. `factor_meta.json` 和 `model_meta.json` **仅记录因子名称，不记录顺序**

**结论**：
- 若禁止读取 `combined_factors_df.parquet`，**无法恢复动态因子顺序**
- 需要在训练时显式记录动态因子顺序

### 3.2 如何获取因子训练时的准确输入顺序？

**方案1：从 combined_factors_df.parquet 提取（当前可行方案）**

**优点**：
- 可以准确获取动态因子列顺序
- 与训练时使用的顺序完全一致

**缺点**：
- 依赖 `combined_factors_df.parquet` 文件存在
- 用户要求"实盘选股禁止使用回测数据"

**方案2：在训练时显式记录因子顺序（推荐方案）**

**实现思路**：
1. 在 `write_loop_artifacts()` 中，从 `combined_factors_df.parquet` 读取列顺序
2. 将完整的因子顺序（Alpha158 + 动态因子）写入 `factor_meta.json` 或新的 `factor_order.json`
3. AIstock 侧从 `factor_meta.json` 或 `factor_order.json` 读取因子顺序

**代码位置**：`rdagent/utils/artifacts_writer.py:write_loop_artifacts()`

```python
# 在 write_loop_artifacts() 中添加
if combined_factors.exists():
    try:
        import pyarrow.parquet as pq
        meta = pq.read_metadata(combined_factors)
        all_cols = meta.schema.names
        
        # 提取因子顺序（排除索引列）
        factor_order = [name for name in all_cols 
                       if name not in ("datetime", "instrument", "index", "level_0", "level_1")]
        
        # 将因子顺序写入 factor_meta_payload
        factor_meta_payload["factor_order"] = factor_order
    except Exception:
        pass
```

**优点**：
- 不依赖 `combined_factors_df.parquet`（训练时读取一次，之后使用 `factor_order.json`）
- 实盘选股时可以获取准确的因子顺序
- 与训练时使用的顺序完全一致

**缺点**：
- 需要修改 `write_loop_artifacts()` 代码
- 需要修改 `factor_meta.json` schema

### 3.3 如何获取所有必须的文件资产？

**必须获取的文件资产**：

1. **模型权重文件**：`model.pkl` 或 `params.pkl`
   - 位置：最后一个被接受的因子实验 workspace/mlruns/.../artifacts/
   - 获取方式：从 session/trace 定位 workspace，然后从 mlruns/meta.yaml 读取 artifact_uri

2. **SOTA 因子源码文件**：
   - 位置：workspace 内的 `*.py` 文件
   - 获取方式：`_sync_factor_impl_to_shared_lib()` 在 workspace 内遍历 `*.py`，通过正则匹配提取

3. **因子顺序信息**：
   - 位置：`factor_meta.json` 或 `factor_order.json`
   - 获取方式：从 `combined_factors_df.parquet` 提取列顺序，写入 `factor_meta.json`

4. **模型元数据**：`model_meta.json`
   - 位置：workspace 根目录
   - 获取方式：`_extract_model_metadata_from_workspace()` 提取

5. **训练合同信息**：`model_meta.json` 中的 `dataset_conf` 和 `feature_schema`
   - 位置：workspace 根目录
   - 获取方式：从 YAML 配置文件提取

## 四、解决方案

### 4.1 短期方案（不修改 RD-Agent 源码）

**限制**：
- 必须读取 `combined_factors_df.parquet` 才能获取动态因子顺序
- 无法满足"实盘选股禁止使用回测数据"的要求

**实现步骤**：
1. 从 session/trace 定位最后一个被接受的因子实验
2. 从 workspace 读取 `combined_factors_df.parquet`，提取列顺序
3. 从 workspace 读取 `model_meta.json`，提取 Alpha158 基线顺序
4. 合并得到完整因子顺序：`[Alpha158列] + [动态因子列]`
5. 从 workspace 读取模型权重文件
6. 从 workspace 读取 SOTA 因子源码文件

### 4.2 长期方案（修改 RD-Agent 源码）

**目标**：
- 在训练时显式记录因子顺序
- 实盘选股时无需读取 `combined_factors_df.parquet`

**实现步骤**：
1. 修改 `rdagent/utils/artifacts_writer.py:write_loop_artifacts()`
2. 从 `combined_factors_df.parquet` 读取列顺序，写入 `factor_meta.json` 的 `factor_order` 字段
3. AIstock 侧从 `factor_meta.json` 读取 `factor_order`，获取完整因子顺序

**代码修改**：

```python
# rdagent/utils/artifacts_writer.py:write_loop_artifacts()
def write_loop_artifacts(
    reg: Any,
    *,
    task_run_id: str,
    scenario: str,
    log_trace_path: str,
    loop_id: int,
    step_name: str,
    action: str | None,
    status: str,
    metrics: dict[str, Any] | None,
    exp_obj: Any,
) -> None:
    # ...
    if has_result:
        # ...
        
        # 2. 增强逻辑：从 combined_factors_df.parquet 中提取全量因子名和顺序
        if combined_factors.exists():
            try:
                import pyarrow.parquet as pq
                meta = pq.read_metadata(combined_factors)
                all_cols = meta.schema.names
                
                # 提取因子顺序（排除索引列）
                factor_order = [name for name in all_cols 
                               if name not in ("datetime", "instrument", "index", "level_0", "level_1")]
                
                factor_meta_payload = factor_meta_payload or {
                    "version": "v1",
                    "task_run_id": task_run_id,
                    "loop_id": loop_id,
                    "created_at_utc": datetime.now(timezone.utc).isoformat(),
                    "factors": []
                }
                
                # 将因子顺序写入 factor_meta_payload
                factor_meta_payload["factor_order"] = factor_order
                
                # ...（后续代码不变）
```

## 五、结论

### 5.1 当前限制

1. **动态因子顺序无法恢复**（若禁止读取 `combined_factors_df.parquet`）
2. **SOTA 源码提取不确定性**（依赖因子名与代码定义名称一致）
3. **权重定位依赖 workspace**（需要保证 workspace 未被清理）

### 5.2 推荐方案

**短期方案**（不修改 RD-Agent 源码）：
- 从 `combined_factors_df.parquet` 提取列顺序
- 限制：无法满足"实盘选股禁止使用回测数据"的要求

**长期方案**（修改 RD-Agent 源码）：
- 在 `write_loop_artifacts()` 中，从 `combined_factors_df.parquet` 读取列顺序，写入 `factor_meta.json` 的 `factor_order` 字段
- AIstock 侧从 `factor_meta.json` 读取 `factor_order`，获取完整因子顺序
- 优点：实盘选股时无需读取 `combined_factors_df.parquet`

### 5.3 实施建议

1. **立即实施**：修改 `write_loop_artifacts()`，添加 `factor_order` 字段
2. **测试验证**：确保 `factor_order` 与训练时使用的顺序一致
3. **AIstock 适配**：修改 AIstock 侧代码，从 `factor_meta.json` 读取 `factor_order`
