# 因子实现常见错误案例集 v1（草案）

> 版本：v0.1  
> 作用：为 LLM 和开发者提供“错误实现 vs 正确实现”的对比示例，帮助在因子演进过程中避免重复踩坑。

---

## 案例 1：VolAdjMomentum_20D 时间窗口错位与除零问题

### 1.1 因子定义

- 目标因子：\( VolAdjMomentum\_20D = Momentum\_20D / Volatility\_20D \)
- 其中：
  - \( Momentum\_20D(t) = Close_t / Close_{t-20} - 1 \)
  - \( Volatility\_20D(t) \) 应基于 **过去 20 日收益率** 的标准差：`R_{t-1} ... R_{t-20}`。

### 1.2 错误实现示例（简化伪代码）

```python
close = df["close"].unstack("instrument")
ret = close.pct_change()

# 错误：直接 rolling(window=20)，窗口为 [t-19, t]
vol_20 = ret.rolling(window=20).std()

mom_20 = close / close.shift(20) - 1
vol_adj_mom_20 = mom_20 / vol_20
```

**问题分析：**

1. 时间窗口不对齐：
   - 分子 `Momentum_20D` 使用 `[t, t-20]` 区间价格；
   - 分母 `Volatility_20D` 实际使用 `[t, t-19]` 区间收益率（因为包含了 `R_t`，而缺少 `R_{t-20}`）。
   - 结果是分母“看得更远一点”，在时间轴上存在微小的“未来信息”，属于前视偏差的一种形式。
2. 未处理波动率为 0 的情况：
   - 当某段时间无波动或数据缺失、停牌时，`vol_20` 可能为 0；
   - 直接相除可能导致 `inf` / `NaN`，在后续回测中引发异常或不稳定行为。

### 1.3 推荐实现示例

```python
close = df["close"].unstack("instrument").sort_index()
ret = close.pct_change()

# 先 shift(1)，再 rolling，窗口严格为 [t-1, t-20]
ret_shifted = ret.shift(1)
vol_20 = ret_shifted.rolling(window=20).std()

mom_20 = close / close.shift(20) - 1

# 数值稳定性：分母加一个很小的平滑项
eps = 1e-12
vol_adj_mom_20 = mom_20 / (vol_20 + eps)

# stack 回 MultiIndex 结构
vol_adj_mom_20 = vol_adj_mom_20.stack().to_frame("vol_adj_mom_20")
```

**经验总结：**

- 对“收益率波动率”一类因子，通常应使用过去若干日的历史收益率，不应包含当日收益；
- 对分母可能接近 0 的情况，添加小平滑项是常规做法；
- 需要特别留意“分子窗口 vs 分母窗口”是否对齐。

---

## 案例 2：混用 `$close` 与 `close` 列名

### 2.1 问题背景

- `daily_pv.h5` 中原始列名为 Qlib 风格：`$close`, `$open`, ...；
- 项目规范要求在读取后统一重命名为无 `$` 前缀的业务名：`close`, `open`, ...；
- 若在同一段代码中混用 `$close` 与 `close`，容易导致：
  - KeyError；
  - 逻辑混乱（误以为使用的是同一列）。

### 2.2 错误示例

```python
df = pd.read_hdf("daily_pv.h5", key="data")

# 部分代码直接使用 "$close"
ret1 = df["$close"].groupby(level="instrument").pct_change()

# 部分代码又使用 "close"（但实际上并不存在）
ret2 = df["close"].groupby(level="instrument").pct_change()
```

### 2.3 推荐做法

- 统一在读取后立即重命名：

```python
df = pd.read_hdf("daily_pv.h5", key="data").sort_index()
rename_map = {
    "$open": "open",
    "$high": "high",
    "$low": "low",
    "$close": "close",
    "$volume": "volume",
    "$amount": "amount",
}

df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})
```

- 后续所有代码只允许使用不带 `$` 的列名，例如：`df["close"]`。

**经验总结：**

- 列名重命名应在因子代码的最前面统一完成，避免后续逻辑中出现一会儿 `$close` 一会儿 `close` 的混乱情况；
- RAG 为 LLM 提供示例时，应优先使用已经重命名后的列名，减少错误。

---

## 案例 3：使用未来信息（look-ahead bias）

### 3.1 问题示例

```python
# 错误：直接使用未来 5 日收益作为因子值
close = df["close"].unstack("instrument")
ret_fwd_5 = close.shift(-5) / close - 1
factor = ret_fwd_5.stack().to_frame("future_5d_ret")
```

- 这种“未来收益因子”在回测中会表现极好，但在真实交易中无法实现，因为在 t 日无法知道未来 5 日收益。

### 3.2 合法用法

- 未来收益应该作为 **标签（label）**，而不是因子：
  - 在 Qlib 配置中通常由 `label` 配置负责；
  - 因子代码只使用过去与当前信息。

**经验总结：**

- 因子实现中只允许使用 `t` 及以前的信息，不允许使用 `t+1` 以及更远的未来信息；
- 未来收益/未来财报/未来公告等字段只能出现在“label 构造”或“回测评价”阶段，不应作为可观测因子输入模型。

---

## 案例 4：过度依赖随机数或虚构数据

### 4.1 问题示例

```python
# 错误：为了快速示例，使用随机数代替真实因子
import numpy as np

idx = df.index
random_factor = np.random.randn(len(idx))
result = pd.DataFrame(random_factor, index=idx, columns=["random_factor"])
```

- 虽然可以跑通，但完全不依赖真实市场信息，回测结果没有任何参考价值。

### 4.2 合理做法

- 所有因子必须基于真实的历史数据构造（价格、成交量、资金流、筹码等）；
- 如需调试，可在极小样本上做随机实验，但不应将随机因子作为正式研究结果。

---

## 使用建议

- RAG 在为“因子修正 / 错误分析”类任务提供上下文时，应优先返回：
  - 与当前报错或行为相似的错误案例；
  - 对应的“正确实现示例”和“经验总结”。
- LLM 在看到这些案例后，应：
  - 主动对照当前实现与案例中的错误点；
  - 解释自己如何避免同样的问题；
  - 给出修正后的代码或思路，而不仅是“表面改名”。
