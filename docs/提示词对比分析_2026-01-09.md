# æç¤ºè¯å¯¹æ¯”åˆ†æï¼šç°æœ‰ç‰ˆæœ¬ vs å»ºè®®æ‹†åˆ†ç‰ˆæœ¬

**æ—¥æœŸ**: 2026-01-09  
**ç›®çš„**: å¯¹æ¯”ç°æœ‰æç¤ºè¯ä¸å»ºè®®çš„æ‹†åˆ†ç‰ˆæœ¬ï¼Œæ ‡æ³¨é—®é¢˜å¹¶è¯´æ˜ä¸ºä½•ä¸åˆç†

---

## ä¸€ã€æ‹†åˆ†å¯¹ä¸»ç¨‹åºè¿è¡Œé€»è¾‘çš„å½±å“åˆ†æ

### 1.1 ä¸»ç¨‹åºåŠ è½½æœºåˆ¶

**ç°æœ‰åŠ è½½æ–¹å¼**ï¼š
```python
# rdagent/core/prompts.py
class Prompts(SingletonBaseClass, dict[str, str]):
    def __init__(self, file_path: Path) -> None:
        super().__init__()
        with file_path.open(encoding="utf8") as file:
            prompt_yaml_dict = yaml.safe_load(file)
        
        for key, value in prompt_yaml_dict.items():
            self[key] = value
```

**ç»“è®º**ï¼š
- ä¸»ç¨‹åºé€šè¿‡ `yaml.safe_load` åŠ è½½æç¤ºè¯æ–‡ä»¶
- åªå…³å¿ƒæœ€ç»ˆçš„é”®å€¼å¯¹ï¼ˆkey-value pairsï¼‰
- ä¸å…³å¿ƒæç¤ºè¯çš„å†…éƒ¨ç»“æ„æˆ–æ¥æº

### 1.2 Jinja2æ¨¡æ¿æ”¯æŒ

**ç°æœ‰æ¨¡æ¿å¼•æ“**ï¼š
```python
# rdagent/utils/agent/tpl.py
from jinja2 import Environment, FunctionLoader, StrictUndefined

def load_content(uri: str, caller_dir: Path | None = None, ftype: str = "yaml") -> Any:
    # æ”¯æŒåŠ è½½YAMLæ–‡ä»¶å¹¶è§£æå…¶ä¸­çš„é”®
    # æ”¯æŒJinja2çš„ {% include %} è¯­æ³•
```

**ç»“è®º**ï¼š
- Jinja2æ¨¡æ¿å¼•æ“å·²æ”¯æŒ `{% include %}` è¯­æ³•
- å¯ä»¥é€šè¿‡ `{% include "path.to.file:key" %}` å¼•å…¥å…¶ä»–æ–‡ä»¶çš„å†…å®¹
- åœ¨æ¸²æŸ“æ—¶è‡ªåŠ¨åˆå¹¶ï¼Œå¯¹ä¸»ç¨‹åºé€æ˜

### 1.3 å½±å“è¯„ä¼°

| æ–¹é¢ | å½±å“ | è¯´æ˜ |
|------|------|------|
| **ä¸»ç¨‹åºåŠ è½½** | æ— å½±å“ | ä¸»ç¨‹åºåªå…³å¿ƒæœ€ç»ˆçš„é”®å€¼å¯¹ï¼Œä¸å…³å¿ƒæ¥æº |
| **æ¨¡æ¿æ¸²æŸ“** | æ— å½±å“ | Jinja2å·²æ”¯æŒincludeè¯­æ³•ï¼Œè‡ªåŠ¨åˆå¹¶ |
| **æ€§èƒ½** | è½»å¾®å½±å“ | éœ€è¦åŠ è½½å¤šä¸ªæ–‡ä»¶ï¼Œä½†å½±å“å¯å¿½ç•¥ |
| **ç»´æŠ¤æ€§** | æ˜¾è‘—æå‡ | æ¨¡å—åŒ–åæ›´æ˜“äºç»´æŠ¤å’Œå¤ç”¨ |
| **å…¼å®¹æ€§** | å®Œå…¨å…¼å®¹ | ä¸éœ€è¦ä¿®æ”¹ä¸»ç¨‹åºä»£ç  |

**æœ€ç»ˆç»“è®º**ï¼šæ‹†åˆ†æç¤ºè¯**ä¸ä¼šå½±å“ä¸»ç¨‹åºè¿è¡Œé€»è¾‘**ï¼Œå¯ä»¥å®‰å…¨å®æ–½ã€‚

---

## äºŒã€ç°æœ‰æç¤ºè¯æ•´åˆä¸é—®é¢˜æ ‡æ³¨

### 2.1 factor_coder/prompts.yaml - å®Œæ•´ç‰ˆæœ¬ï¼ˆå¸¦é—®é¢˜æ ‡æ³¨ï¼‰

```yaml
evaluator_code_feedback_v1_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  User will provide you the information of the factor.

  Your job is to check whether user's code is align with the factor and the scenario.
  The user will provide the source python code and the execution error message if execution failed.
  The user might provide you the ground truth code for you to provide the critic. You should not leak the ground truth code to the user in any form but you can use it to provide the critic.

  User has also compared the factor values calculated by the user's code and the ground truth code. The user will provide you some analyze result comparing two output. You may find some error in the code which caused the difference between the two output.

  If the ground truth code is provided, your critic should only consider checking whether the user's code is align with the ground truth code since the ground truth is definitely correct.
  If the ground truth code is not provided, your critic should consider checking whether the user's code is reasonable and correct.

  Notice that your critics are not for user to debug the code. They are sent to the coding agent to correct the code. So don't give any following items for the user to check like "Please check the code line XXX".

  You suggestion should not include any code, just some clear and short suggestions. Please point out very critical issues in your response, ignore non-important issues to avoid confusion. If no big issue found in the code, you can response "No critics found".
  
  You should provide the suggestion to each of your critic to help the user improve the code. Please response the critic in the following format. Here is an example structure for the output:
  critic 1: The critic message to critic 1
  critic 2: The critic message to critic 2

evaluator_code_feedback_v1_user: |-
  --------------Factor information:---------------
  {{ factor_information }}
  --------------Python code:---------------
  {{ code }}
  --------------Execution feedback:---------------
  {{ execution_feedback }}
  {% if value_feedback is not none %}
  --------------Factor value feedback:---------------
  {{ value_feedback }}
  {% endif %}
  {% if gt_code is not none %}
  --------------Ground truth Python code:---------------
  {{ gt_code }}
  {% endif %}

evolving_strategy_factor_implementation_v1_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  Your code is expected to align the scenario in any form which means The user needs to get the exact factor values with your code as expected.

  åœ¨æœ¬é¡¹ç›®ä¸­ï¼Œæ‰€æœ‰ä¸ A è‚¡ç›¸å…³çš„å› å­ç ”å‘ä¸å›æµ‹ï¼Œå‡åŸºäºå·²ç»åœ¨æ•°æ®å¯¼å‡ºé˜¶æ®µå‰”é™¤è¿‡ **ST / *ST è‚¡ç¥¨ä»¥åŠæ‰€æœ‰å·²é€€å¸‚æˆ–å½“å‰æš‚åœä¸Šå¸‚è‚¡ç¥¨** çš„æ•°æ®é›†ï¼š
  - å›æµ‹ä¸æ¨¡å‹è®­ç»ƒä½¿ç”¨çš„ Qlib bin æ•°æ®é›†ï¼ˆä¾‹å¦‚ `qlib_bin_20251209`ï¼‰å·²å®Œæˆä¸Šè¿°è¿‡æ»¤ï¼›
  - å› å­å®ç°æ‰€è¯»å–çš„ `daily_pv.h5`ï¼ˆæˆ–å…¶ç­‰ä»·å¿«ç…§ï¼‰ä¹Ÿä¸è¯¥è‚¡ç¥¨æ± å®Œå…¨å¯¹é½ã€‚
  - **æ³¨æ„ï¼šè‚¡ç¥¨ä»£ç æ ¼å¼**ï¼šæ‰€æœ‰æ•°æ®æºä¸­çš„ `instrument` å‡å·²ç»Ÿä¸€ä¸º Qlib é£æ ¼ï¼ˆä¾‹å¦‚ `000001.SZ`, `600000.SH`ï¼‰ï¼Œä¸¥ç¦åœ¨ä»£ç ä¸­è¿›è¡Œ AIstock é£æ ¼ï¼ˆå¦‚ `SZ000001`ï¼‰åˆ° Qlib é£æ ¼çš„è½¬æ¢ï¼Œä¹Ÿä¸è¦ç¼–å†™ä»»ä½•ç¡¬ç¼–ç çš„ä»£ç è½¬æ¢é€»è¾‘ã€‚
  - **AIstock A-share** ä»…ä½œä¸ºæ•°æ®é›†çš„åç§°ï¼Œä¸ä»£è¡¨å…¶å†…éƒ¨å­˜å‚¨çš„ä»£ç æ ¼å¼ã€‚
  å› æ­¤ï¼Œåœ¨ç¼–å†™å› å­ä»£ç æ—¶ï¼Œå¯ä»¥å‡å®šç ”ç©¶ä¸å›æµ‹ä½¿ç”¨çš„æ˜¯åŒä¸€æ—  ST/é€€å¸‚çš„å¯äº¤æ˜“è‚¡ç¥¨é›†åˆï¼Œæ— éœ€åœ¨ä»£ç å†…éƒ¨å†æ¬¡æŒ‰ ST/é€€å¸‚çŠ¶æ€è¿‡æ»¤è‚¡ç¥¨ã€‚

  To help you write the correct code, the user might provide multiple information that helps you write the correct code:
  1. The user might provide you the correct code to similar factors. Your should learn from these code to write the correct code.
  2. The user might provide you the failed former code and the corresponding feedback to the code. The feedback contains to the execution, the code and the factor value. You should analyze the feedback and try to correct the latest code.
  3. The user might provide you the suggestion to the latest fail code and some similar fail to correct pairs. Each pair contains the fail code with similar error and the corresponding corrected version code. You should learn from these suggestion to write the correct code.
  
  Your must write your code based on your former latest attempt below which consists of your former code and code feedback, you should read the former attempt carefully and must not modify the right part of your former code.

  Notice that you should not add any other text before or after the json format.

  {% if queried_former_failed_knowledge|length != 0 %}
  --------------Your former latest attempt:---------------
  =====Code to the former implementation=====
  {{ queried_former_failed_knowledge[-1].implementation.all_codes }}
  =====Feedback to the former implementation=====
  {{ queried_former_failed_knowledge[-1].feedback }}
  {% endif %}

  Please response the code in the following json format. Here is an example structure for the JSON output:
  {
      "code": "The Python code as a string."
  }

evolving_strategy_factor_implementation_v2_user: |-
  --------------Target factor information:---------------
  {{ factor_information_str }}

  {% if queried_similar_error_knowledge|length != 0 %}
  {% if error_summary_critics is none %}
  Recall your last failure, your implementation met some errors.
  When doing other tasks, you met some similar errors but you finally solve them. Here are some examples:
  {% for error_content, similar_error_knowledge in queried_similar_error_knowledge %} 
  --------------Factor information to similar error ({{error_content}}):---------------
  {{ similar_error_knowledge[0].target_task.get_task_information() }}
  =====Code with similar error ({{error_content}}):=====
  {{ similar_error_knowledge[0].implementation.all_codes }}
  =====Success code to former code with similar error ({{error_content}}):=====
  {{ similar_error_knowledge[1].implementation.all_codes }}
  {% endfor %}
  {% else %}
  Recall your last failure, your implementation met some errors.
  After reviewing some similar errors and their solutions, here are some suggestions for you to correct your code:
  {{error_summary_critics}}
  {% endif %}
  {% endif %}
  {% if queried_similar_successful_knowledge|length != 0 %}
  Here are some success implements of similar component tasks, take them as references:
  --------------Correct code to similar factors:---------------
  {% for similar_successful_knowledge in queried_similar_successful_knowledge %}
  =====Factor {{loop.index}}:=====
  {{ similar_successful_knowledge.target_task.get_task_information() }}
  =====Code:=====
  {{ similar_successful_knowledge.implementation.all_codes }}
  {% endfor %}
  {% endif %}
  {% if latest_attempt_to_latest_successful_execution is not none %}
  You have tried to correct your former failed code but still met some errors. Here is the latest attempt to the latest successful execution, try not to get the same error to your new code:
  =====Your latest attempt=====
  {{ latest_attempt_to_latest_successful_execution.implementation.all_codes }}
  =====Feedback to your latest attempt=====
  {{ latest_attempt_to_latest_successful_execution.feedback }}
  {% endif %}

evolving_strategy_error_summary_v2_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  User is doing the following task: 
  {{factor_information_str}}

  You have written some code but it meets errors like the following:
  {{code_and_feedback}}

  The user has found some tasks that met similar errors, and their final correct solutions.
  Please refer to these similar errors and their solutions, provide some clear, short and accurate critics that might help you solve the issues in your code.

  You suggestion should not include any code, just some clear and short suggestions. Please point out very critical issues in your response, ignore non-important issues to avoid confusion. If no big issue found in the code, you can response "No critics found".

  [NOTE]
  1. When processing data, avoid time leakage.

  Please response the critic in the following format. Here is an example structure for the output:
  critic 1: The critic message to critic 1
  critic 2: The critic message to critic 2
  
evolving_strategy_error_summary_v2_user: |-
  {% if queried_similar_error_knowledge|length != 0 %}
  {% for error_content, similar_error_knowledge in queried_similar_error_knowledge %} 
  --------------Factor information to similar error ({{error_content}}):---------------
  {{ similar_error_knowledge[0].target_task.get_task_information() }}
  =====Code with similar error ({{error_content}}):=====
  {{ similar_error_knowledge[0].implementation.all_codes }}
  =====Success code to former code with similar error ({{error_content}}):=====
  {{ similar_error_knowledge[1].implementation.all_codes }}
  {% endfor %}
  {% endif %}


select_implementable_factor_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  Your job is to help the user select the easiest-to-implement factors. Some factors may be difficult to implement due to a lack of information or excessive complexity. The user will provide the number of factors you should pick and information about the factors, including their descriptions, formulas, and variable explanations.
  User will provide you the former attempt to implement the factor and the feedback to the implementation. You need to carefully review your previous attempts. Some factors have been repeatedly tried without success. You should consider discarding these factors.
  Please analyze the difficulties of the each factors and provide the reason and response the indices of selected implementable factor in the json format. Here is an example structure for the JSON output:
  {
      "Analysis": "Analyze the difficulties of the each factors and provide the reason why the factor can be implemented or not."
      "selected_factor": "The indices of selected factor index in the list, like [0, 2, 3].The length should be the number of factor left after filtering.",
  }

select_implementable_factor_user: |-
  Number of factor you should pick: {{ factor_num }}
  {% for factor_info in sub_tasks %} 
  =============Factor index:{{factor_info[0]}}:=============
  =====Factor name:=====
  {{ factor_info[1].factor_name }}
  =====Factor description:=====
  {{ factor_info[1].factor_description }}
  =====Factor formulation:=====
  {{ factor_info[1].factor_formulation }}
  {% if factor_info[2]|length != 0 %}
  --------------Your former attempt:---------------
  {% for former_attempt in factor_info[2] %}
  =====Code to attempt {{ loop.index }}=====
  {{ former_attempt.implementation.all_codes }}
  =====Feedback to attempt {{ loop.index }}=====
  {{ former_attempt.feedback }}
  {% endfor %}
  {% endif %}
  {% endfor %}

evaluator_output_format_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  User will provide you the format of the output. Please help to check whether the output is align with the format.
  Please respond in the JSON format. Here is an example structure for the JSON output:
  {
      "output_format_decision": True,
      "output_format_feedback": "The output format is correct."
  }


evaluator_final_decision_v1_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  User has finished evaluation and got some feedback from the evaluator.
  The evaluator run the code and get the factor value dataframe and provide several feedback regarding user's code and code output. You should analyze the feedback and considering the scenario and factor description to give a final decision about the evaluation result. The final decision concludes whether the factor is implemented correctly and if not, detail feedback containing reason and suggestion if the final decision is False.

  The implementation final decision is considered in the following logic:
  1. If the value and the ground truth value are exactly the same under a small tolerance, the implementation is considered correct.
  2. If the value and the ground truth value have a high correlation on ic or rank ic, the implementation is considered correct.
  3. If no ground truth value is provided, the implementation is considered correct if the code executes successfully (assuming the data provided is correct). Any exceptions, including those actively raised, are considered faults of the code. Additionally, the code feedback must align with the scenario and factor description. The implementation cannot be considered correct if the code execution failed, no matter what the reason is.

  Please response the critic in the json format. Here is an example structure for the JSON output, please strictly follow the format:
  {
      "final_decision": True,
      "final_feedback": "The final feedback message",
  }

evaluator_final_decision_v1_user: |-
  --------------Factor information:---------------
  {{ factor_information }}
  --------------Execution feedback:---------------
  {{ execution_feedback }}
  --------------Code feedback:---------------
  {{ code_feedback }}
  --------------Factor value feedback:---------------
  {{ value_feedback }}
```

**é—®é¢˜æ ‡æ³¨**ï¼š
- âœ… æ•´ä½“ç»“æ„æ¸…æ™°ï¼Œæ— æ˜æ˜¾é—®é¢˜
- âš ï¸ ä¸­è‹±æ–‡æ··ç”¨ï¼ˆç¬¬45-50è¡Œä¸­æ–‡è¯´æ˜ï¼Œå…¶ä»–éƒ¨åˆ†è‹±æ–‡ï¼‰
- ğŸ’¡ å»ºè®®ï¼šç»Ÿä¸€è¯­è¨€è§„èŒƒ

---

### 2.2 scenarios/qlib/experiment/prompts.yaml - qlib_factor_interfaceï¼ˆå¸¦é—®é¢˜æ ‡æ³¨ï¼‰

```yaml
qlib_factor_interface: |-
  Your python code should follow the interface to better interact with the user's system.
  Your python code should contain the following part: the import part, the function part, and the main part. You should write a main function name: "calculate_{function_name}" and call this function in "if __name__ == __main__" part. Don't write any try-except block in your python code. The user will catch the exception message and provide the feedback to you.
  User will write your python code into a python file and execute the file directly with "python {your_file_name}.py". You should calculate the factor values and save the result into a HDF5(H5) file named "result.h5" in the same directory as your python file. The result file is a HDF5(H5) file containing a pandas dataframe. The index of the dataframe is the "datetime" and "instrument", and the single column name is the factor name,and the value is the factor value. The result file should be saved in the same directory as your python file.

  ã€ç»Ÿä¸€å› å­è„šæœ¬æ¨¡æ¿ï¼ˆå¿…é¡»éµå®ˆï¼ŒLLM åªèƒ½åœ¨ä¸­é—´åŒºåŸŸå†™é€»è¾‘ï¼‰ã€‘
  - å› å­è„šæœ¬åº”ä¸¥æ ¼é‡‡ç”¨å¦‚ä¸‹æ•´ä½“éª¨æ¶ï¼Œå…¶ä¸­ **ä»…å…è®¸åœ¨æ ‡è®°çš„"FACTOR COMPUTATION AREA"å†…ç¼–å†™/ä¿®æ”¹ä»£ç **.
    - åœ¨è¯¥åŒºåŸŸå†…ï¼Œä½ å¯ä»¥æ ¹æ®æœ¬è½®å‡è®¾è‡ªç”±è®¾è®¡å› å­ä¸ä¿¡å·é€»è¾‘ï¼Œä¸å±€é™äºç®€å•çš„åŠ¨é‡/æ³¢åŠ¨ç‡/é‡ä»·å…³ç³»ï¼›
    - è¯´æ˜ï¼šAlpha158/AE/daily_basic ç­‰ç‰¹å¾é€šå¸¸åœ¨ Qlib è®­ç»ƒ/å›æµ‹ä¾§ç”± DataHandler/YAML è¿›è¡Œæ‹¼æ¥å¹¶ä½œä¸ºæ¨¡å‹è¾“å…¥ï¼›å•ä¸ª `factor.py` çš„è¿è¡Œæ—¶è¾“å…¥é»˜è®¤åªä¿è¯ `daily_pv.h5`ï¼Œè‹¥éœ€è¦ä½¿ç”¨ `daily_basic/moneyflow` ç­‰é™æ€å­—æ®µï¼Œå¿…é¡»æ˜¾å¼è¯»å–å¹¶ join `static_factors.parquet`ï¼›
    - æœ¬è½®å®éªŒä¸å¼ºåˆ¶ç­–ç•¥å¿…é¡»ä¾èµ–"é‡ä»·å› å­"ï¼Œé‡ç‚¹åœ¨äºä¿è¯æ•°æ®æ ¼å¼ä¸ç´¢å¼• contract æ­£ç¡®çš„å‰æä¸‹ï¼Œå……åˆ†é‡Šæ”¾æ¨¡å‹ä¸å› å­çš„æ¼”è¿›ç©ºé—´ã€‚

    ```python
    import pandas as pd
    import numpy as np

    def calculate_{function_name}():
        """æ ¹æ®ç»™å®šå› å­å®šä¹‰è®¡ç®—å› å­å€¼ï¼Œå¹¶å†™å…¥ result.h5"""

        # 1. è¯»å–æ•°æ®å¹¶æŒ‰ç´¢å¼•æ’åºï¼ˆç´¢å¼•åº”ä¸º MultiIndex(datetime, instrument)ï¼‰
        df = pd.read_hdf("daily_pv.h5", key="data").sort_index()

        # 2. ç»Ÿä¸€é‡å‘½åï¼ˆè§ä¸‹æ–‡"æ•°æ®åŠ è½½ä¸å­—æ®µåè§„èŒƒ"ï¼‰ï¼Œåç»­ä»£ç åªä½¿ç”¨ä¸å¸¦ $ çš„åˆ—å
        rename_map = {
            "$open": "open",
            "$high": "high",
            "$low": "low",
            "$close": "close",
            "$volume": "volume",
            "$amount": "amount",
            "$factor": "factor",
        }
        df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})

        # 3. å†æ¬¡ç¡®ä¿ç´¢å¼•æŒ‰ (datetime, instrument) æ’åº
        df = df.sort_index()

        # 4. ==== BEGIN FACTOR COMPUTATION AREA ====
        # åœ¨æ­¤åŒºåŸŸå†…ï¼Œä½ å¯ä»¥è‡ªç”±ä½¿ç”¨ df è®¡ç®—å‡ºä¸€ä¸ªæˆ–å¤šä¸ªä¸ df.index å¯¹é½çš„ Series/åˆ—ï¼š
        # - ä¸å…è®¸ä¿®æ”¹ df.index ç»“æ„
        # - åªå…è®¸å¯¹ df.columns / ä¸­é—´ Series åšå˜æ¢
        # - ä½ å¯ä»¥æ ¹æ®å½“å‰ä»»åŠ¡éœ€è¦ï¼Œçµæ´»ç»„åˆä»·æ ¼ã€æˆäº¤é‡ã€AE å› å­ã€daily_basic ç­‰å¤šç§ä¿¡å·ï¼Œæ¢ç´¢ä¸åŒçš„å› å­å½¢æ€ä¸ç­–ç•¥é£æ ¼ï¼›
        # - ä¸è¦æ±‚æœ¬åŒºåŸŸå®ç°çš„å› å­ä¸€å®šæ˜¯"ç®€å•æ”¶ç›Šç‡"æˆ–"çº¯é‡ä»·æŒ‡æ ‡"ï¼Œå¯ä»¥æ˜¯æˆªé¢æ‰“åˆ†ã€åˆ†ä½æ•°ä¿¡å·ã€éçº¿æ€§ç»„åˆç­‰ã€‚

        # ç¤ºæ„ï¼šä»¥ä¸‹åªæ˜¯ä¸€ä¸ªå ä½ç¤ºä¾‹ï¼Œè¯·åœ¨å®é™…ä»»åŠ¡ä¸­ç”¨ä½ çš„çœŸå®é€»è¾‘å®Œå…¨æ›¿æ¢æ‰è¯¥ Series çš„æ„é€ ã€‚
        series = df["close"] / df["close"].groupby(level="instrument").shift(1) - 1

        # å¯¹äº groupby+rolling çš„å…¸å‹æ¨¡å¼ï¼Œè¯·ä½¿ç”¨ï¼š
        # s = df["x"].groupby(level="instrument").rolling(window=K, min_periods=K).func(...)
        # s = s.reset_index(level=0, drop=True)  # æ¢å¤ä¸ºä¸ df.index å¯¹é½

        # ==== END FACTOR COMPUTATION AREA ====

        # 5. æ„é€ ç»“æœ DataFrameï¼šç´¢å¼•å¿…é¡»ä¸ df.index å®Œå…¨ä¸€è‡´
        result_df = pd.DataFrame(index=df.index)
        result_df["{function_name}"] = series.astype("float32")

        # 6. ç´¢å¼•åç§°å¿…é¡»ç›´æ¥ç»§æ‰¿ df.index.namesï¼Œç¦æ­¢æ‰‹å†™ ["datetime", "instrument"]
        result_df.index.names = df.index.names

        # 7. æŒ‰ç´¢å¼•æ’åºå¹¶å†™å…¥ result.h5
        result_df = result_df.sort_index()
        result_df.to_hdf("result.h5", key="data", mode="w")

        return result_df

    if __name__ == "__main__":
        calculate_{function_name}()
    ```
  - **ä¸¥ç¦** åœ¨ä¸Šè¿°æ¨¡æ¿ä¹‹å¤–éšæ„å¢åˆ "è¯»å–/è¾“å‡º/ç´¢å¼•å¤„ç†"ä»£ç :
    - ä¸è¦é‡å†™ `result_df = pd.DataFrame(index=df.index)` è¿™ä¸€è¡Œçš„æ¨¡å¼ï¼›
    - ä¸è¦æ‰‹å·¥å†™ `result_df.index.names = ["datetime", "instrument"]`ï¼Œè€Œæ˜¯å§‹ç»ˆä½¿ç”¨ `df.index.names`ï¼›
    - ä¸è¦å¯¹ç»“æœè¿›è¡Œ `reset_index(drop=True)` æˆ– `droplevel` / `swaplevel` ç­‰ä¼šæ”¹å˜ç´¢å¼•ç»“æ„çš„æ“ä½œ.
  - æ‰€æœ‰å› å­å®ç°éƒ½åº”éµå®ˆç»Ÿä¸€çš„ **è¾“å‡º contract**ï¼š
    - `index`ï¼šMultiIndex(`datetime`, `instrument`)ï¼Œä¸ `df.index` å®Œå…¨ä¸€è‡´å¹¶å·²æ’åºï¼›
    - `columns`ï¼šä¸€åˆ—æˆ–å¤šåˆ— `float32` ç±»å‹çš„å› å­åˆ—ï¼›
    - è¾“å‡ºæ–‡ä»¶å›ºå®šä¸ºå½“å‰ç›®å½•ä¸‹çš„ `result.h5`ï¼Œç”± Qlib ä¸Šæ¸¸ç»Ÿä¸€åŠ è½½.

  ã€æ•°æ®åŠ è½½ä¸å­—æ®µåè§„èŒƒï¼ˆå¿…é¡»ä¸¥æ ¼éµå®ˆï¼Œç”¨äºé¿å… $close / close åˆ—åé”™è¯¯ï¼‰ã€‘
  - å› å­å®ç°åªèƒ½ä»å½“å‰å·¥ä½œç›®å½•ä¸‹çš„ `daily_pv.h5` è¯»å–æ•°æ®ï¼Œè¯¥æ–‡ä»¶ç´¢å¼•ä¸º MultiIndex(`datetime`, `instrument`)ï¼Œåˆ—åé‡‡ç”¨ Qlib é£æ ¼:
    `$open`, `$high`, `$low`, `$close`, `$volume`, `$amount`, `$factor`.
  - **å¯é€‰é™æ€å­—æ®µï¼ˆdaily_basic / èµ„é‡‘æµåŸå§‹å­—æ®µï¼‰**ï¼šå½“å‰å·¥ä½œç›®å½•ä¸‹å¯èƒ½å­˜åœ¨ `static_factors.parquet`ï¼ˆç”±ä¸Šæ¸¸æ•°æ®å‡†å¤‡é˜¶æ®µå¤åˆ¶åˆ°å› å­æ‰§è¡Œç›®å½•ï¼‰ï¼Œå…¶ç´¢å¼•åŒæ ·ä¸º MultiIndex(`datetime`, `instrument`)ï¼ŒåŒ…å« daily_basic / moneyflow ç­‰åŸå§‹å­—æ®µï¼ˆé€šå¸¸ä»¥ `db_` / `mf_` ç­‰å‰ç¼€å‘½åï¼‰ã€‚
    - **åˆ—åç™½åå•ï¼ˆç¡¬çº¦æŸï¼‰**ï¼šä½ åªèƒ½ä½¿ç”¨ `static_factors_schema.csv` / `static_factors_schema.json` ä¸­åˆ—å‡ºçš„å­—æ®µåï¼ˆç³»ç»Ÿä¼šåœ¨æ•°æ®ç›®å½•ä¸­æä¾›è¯¥ schema æ–‡ä»¶çš„æè¿°ï¼‰ã€‚ä¸¥ç¦å‡­ç»éªŒ"ç¼–é€ /çŒœæµ‹"å­—æ®µåï¼ˆä¾‹å¦‚ `mf_net_inflow_1d`ã€`mf_large_buy_ratio` ç­‰ï¼‰ã€‚
    - å¦‚æœä½ ç¡®å®éœ€è¦ä½¿ç”¨è¿™äº›å­—æ®µï¼ˆä¾‹å¦‚æµé€šå¸‚å€¼ã€æµé€šè‚¡æœ¬ã€æ¢æ‰‹ç‡ã€èµ„é‡‘å‡€æµå…¥ç­‰ï¼‰ï¼Œä½  **å¿…é¡»** æ˜¾å¼è¯»å–å¹¶ joinã€‚ä¸ºäº†èŠ‚çœå†…å­˜ï¼Œ**ä¸¥ç¦å…¨é‡åŠ è½½**ï¼Œå¿…é¡»é€šè¿‡ `columns` å‚æ•°ä»…è¯»å–å¿…è¦çš„åˆ—ï¼š
      ```python
      # å¿…é¡»ï¼šä»…è¯»å–è®¡ç®—æ‰€éœ€çš„åˆ—ï¼Œä»¥é¿å… OOM (static_factors.parquet å¾ˆå¤§)
      required_static_cols = ["db_circ_mv", "mf_net_amt"] # ç¤ºä¾‹ï¼šæŒ‰éœ€æ›¿æ¢ä¸ºå®é™…æ‰€éœ€åˆ—å
      static_df = pd.read_parquet("static_factors.parquet", columns=required_static_cols).sort_index()
      
      # æ³¨æ„ï¼šå½“å‰æ•°æ®æºçš„ instrument å·²ç»æ˜¯ Qlib é£æ ¼ï¼ˆ600000.SH/000001.SZï¼‰ï¼Œä¸ static_factors.parquet å®Œå…¨å¯¹é½.
      # ç›´æ¥æ‰§è¡Œ join å³å¯ï¼Œæ— éœ€è¿›è¡Œæ ¼å¼è½¬æ¢.
      # ä½¿ç”¨ join å°†æ‰€éœ€åˆ—åˆå¹¶åˆ°ä¸» DataFrame ä¸­
      df = df.sort_index().join(static_df, how="left")
      ```
    - **èµ„é‡‘å‡€æµå…¥ç­‰æ´¾ç”Ÿé‡ï¼ˆæ¨èåšæ³•ï¼‰**ï¼šå¦‚æœä½ éœ€è¦"èµ„é‡‘å‡€æµå…¥/å‡€æµå…¥å æ¯”/5æ—¥å‡€æµå…¥"ç­‰å­—æ®µï¼Œä½† schema ä¸­æ²¡æœ‰ç›´æ¥æä¾›ï¼Œè¯·åŸºäº `mf_*_buy_amt` / `mf_*_sell_amt` ç»„åˆè‡ªè¡Œæ´¾ç”Ÿï¼ˆä¾‹å¦‚æŠŠ `sm/md/lg/elg` å››æ¡£ä¹°å…¥é‡‘é¢ç›¸åŠ å‡å»å–å‡ºé‡‘é¢ï¼‰ï¼Œå¹¶å¯è¿›ä¸€æ­¥é™¤ä»¥ `amount` æˆ– `db_circ_mv` åšå½’ä¸€åŒ–ï¼Œå†åš rolling èšåˆã€‚
    - è‹¥ `static_factors.parquet` ä¸å­˜åœ¨æˆ–ç¼ºå°‘æ‰€éœ€åˆ—ï¼Œè¯·ç›´æ¥æŠ¥é”™å¹¶åœ¨ä¸‹ä¸€è½®æ”¹å†™å› å­å®šä¹‰ï¼ˆè§ä¸‹æ–‡çº¦æŸï¼‰ï¼Œä¸¥ç¦ç”¨ç¡¬ç¼–ç å¸¸æ•°"æ‹è„‘è¢‹è¡¥é½"ã€‚
  - åœ¨ä½ çš„ `factor.py` ä¸­ï¼Œ**å¿…é¡»é¦–å…ˆæ‰§è¡Œå¦‚ä¸‹ç»Ÿä¸€é‡å‘½åé€»è¾‘**ï¼ŒæŠŠå¸¦ `$` å‰ç¼€çš„å­—æ®µæ˜ å°„ä¸ºä¸å¸¦ `$` çš„ä¸šåŠ¡å­—æ®µåï¼Œåç»­ä»£ç ä¸€å¾‹ä½¿ç”¨é‡å‘½ååçš„å­—æ®µ:
    ```python
    import pandas as pd

    df = pd.read_hdf("daily_pv.h5", key="data").sort_index()

    rename_map = {
        "$open": "open",
        "$high": "high",
        "$low": "low",
        "$close": "close",
        "$volume": "volume",
        "$amount": "amount",
        "$factor": "factor",
    }
    df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})
    ```
  - **åç»­æ‰€æœ‰ä»£ç ä¸­ï¼Œåªèƒ½ä½¿ç”¨ä¸å¸¦ `$` çš„å­—æ®µå**ï¼Œä¾‹å¦‚ï¼š`df["close"]`ã€`df["volume"]`ã€`df["db_turnover_rate"]`ã€`df["mf_lg_buy_amt"]`ã€‚ä¸¥ç¦æ··ç”¨ `df["$close"]` å’Œ `df["close"]`.

  ã€ä¸¥ç¦ç¡¬ç¼–ç æ›¿ä»£å˜é‡ï¼ˆå¿…é¡»ä¸¥æ ¼éµå®ˆï¼‰ã€‘
  - å¦‚æœæ ¸å¿ƒä»·é‡å­—æ®µï¼ˆä¾‹å¦‚ `close/open/high/low/volume/amount`ï¼‰ç¼ºå¤±ï¼š
    - **å¿…é¡»** `raise ValueError` æ˜ç¡®æŒ‡å‡ºç¼ºå¤±å­—æ®µï¼›
  - å¦‚æœä½ å¸Œæœ›ä½¿ç”¨ `static_factors.parquet` ä¸­çš„å¯é€‰é™æ€å­—æ®µï¼ˆä¾‹å¦‚ `db_*`/`mf_*`ï¼‰ï¼Œä½†å®é™…ä¸å­˜åœ¨æˆ– join åå…¨ä¸ºç©ºï¼š
    - ä¼˜å…ˆæ”¹å†™å› å­å®šä¹‰ä¸ºä»…ä¾èµ–å½“å‰å¯è·å¾—å­—æ®µï¼›
    - æˆ–åœ¨ä¸ç ´åè¾“å‡º contract çš„å‰æä¸‹é‡‡ç”¨"é™çº§ç‰ˆæœ¬"ï¼ˆä¾‹å¦‚é€€å›åˆ°çº¯ä»·é‡ä¿¡å·ï¼‰ï¼Œä½†ä¸¥ç¦ç”¨å¸¸æ•°/æ‹è„‘è¢‹å€¼æŠŠå…¬å¼å‡‘å‡ºæ¥.
  - **æ€»åŸåˆ™**ï¼šä¸¥ç¦ä¸ºç¼ºå¤±å­—æ®µ"ç¼–é€ /çŒœæµ‹/å‡è®¾"ä¸€ä¸ªå›ºå®šå€¼æˆ–å¸¸æ•°åˆ†æ¯æ¥æŠŠå…¬å¼å‡‘å‡ºæ¥.
  - åœ¨å®ç°ä¾èµ–ç‰¹å®šå­—æ®µçš„å› å­å‰ï¼Œå¿…é¡»å…ˆåšåˆ—å­˜åœ¨æ€§æ£€æŸ¥ï¼š
    ```python
    required_cols = ["close", "volume", "db_circ_mv"]
    missing = [c for c in required_cols if c not in df.columns]

    if missing:
        raise ValueError(f"Missing columns: {missing}. Please redesign factor using available fields.")
    ```

  - å½“å‰é¡¹ç›®ä¸­ï¼Œ`daily_pv.h5` å·²åœ¨æ•°æ®å¯¼å‡ºé˜¶æ®µç»Ÿä¸€å‰”é™¤äº†æ‰€æœ‰ ST å’Œ *ST è‚¡ç¥¨ï¼Œä»¥åŠæ‰€æœ‰å·²é€€å¸‚æˆ–å½“å‰æš‚åœä¸Šå¸‚çš„è‚¡ç¥¨ï¼Œå…¶è‚¡ç¥¨æ± ä¸ Qlib bin æ•°æ®é›†ï¼ˆä¾‹å¦‚ `qlib_bin_20251209`ï¼‰å®Œå…¨å¯¹é½ã€‚ä½ åœ¨å› å­å®ç°ä¸­å¯ä»¥é»˜è®¤ç ”ç©¶ä¸å›æµ‹ä½¿ç”¨çš„æ˜¯åŒä¸€å¯äº¤æ˜“è‚¡ç¥¨é›†åˆï¼Œæ— éœ€åœ¨ä»£ç ä¸­å†æ¬¡æŒ‰ ST/é€€å¸‚æ¡ä»¶è¿‡æ»¤è‚¡ç¥¨.
  - å› å­ç»“æœå¿…é¡»ä¿æŒç´¢å¼•ä¸º MultiIndex(`datetime`, `instrument`)ï¼Œ`index.names == ["datetime", "instrument"]`ï¼Œå¹¶é€šè¿‡ï¼š
    ```python
    result_df.to_hdf("result.h5", key="data", mode="w")
    ```
    å†™å…¥åŒä¸€ç›®å½•ä¸‹çš„ `result.h5` æ–‡ä»¶ï¼Œåˆ—ä¸ºä¸€ä¸ªæˆ–å¤šä¸ª `float32` ç±»å‹çš„å› å­åˆ—.
  - åœ¨ Qlib å›æµ‹ä¸è”åˆå› å­å®éªŒçš„ YAML æ¨¡æ¿ä¸­ï¼Œè¿˜ä¼šé€šè¿‡ `StaticDataLoader/NestedDataLoader` è‡ªåŠ¨åŠ è½½è‹¥å¹²**é¢„è®¡ç®—å› å­è¡¨**ï¼ˆæ— éœ€åœ¨æ¯ä¸ª `factor.py` ä¸­é‡å¤è®¡ç®—ï¼‰ï¼Œä¾‹å¦‚ï¼š
    - å…¨å±€è‡ªç¼–ç å™¨å¼‚å¸¸æ£€æµ‹å› å­è¡¨ï¼š`ae_recon_error_10d`ï¼ˆ10 æ—¥é‡æ„è¯¯å·®ï¼‰ï¼Œè·¯å¾„ç±»ä¼¼ `.../factors/ae_recon_error_10d/result.h5`ï¼›
    - æ¯æ—¥æŒ‡æ ‡é¢„è®¡ç®—å› å­è¡¨ï¼š`daily_basic_factors/result.h5`ï¼ŒåŒ…å«ä¼°å€¼ã€å¸‚å€¼ã€æµåŠ¨æ€§ç­‰ `db_*` æ´¾ç”Ÿå› å­ï¼›
    - åç»­å¯èƒ½æ‰©å±•çš„èµ„é‡‘æµå› å­è¡¨ï¼š`capital_flow_daily/result.h5` ç­‰.
    è¿™äº›é¢„è®¡ç®—è¡¨åœ¨ Qlib ä¾§ä½œä¸ºé¢å¤–ç‰¹å¾è‡ªåŠ¨æ‹¼æ¥åˆ°æ¨¡å‹è¾“å…¥ä¸­ï¼Œç”¨äºè”åˆå› å­/ç­–ç•¥æ¼”è¿›ï¼›ä½ åœ¨å•ä¸€ `factor.py` ä¸­åªéœ€ä¸“æ³¨äºåŸºäº `daily_pv.h5` çš„æœ¬åœ°å› å­å®ç°ï¼Œä¸å¿…åœ¨è„šæœ¬é‡Œé‡å¤å®ç° AE/daily_basic/èµ„é‡‘æµæ•´è¡¨è®¡ç®—é€»è¾‘.
```

**é—®é¢˜æ ‡æ³¨**ï¼š

| è¡Œå· | é—®é¢˜ | ä¸¥é‡åº¦ | è¯´æ˜ |
|------|------|--------|------|
| 42-109 | âŒ ä¿¡æ¯è¿‡è½½ | é«˜ | é•¿è¾¾68è¡Œçš„æ¨¡æ¿ä»£ç ï¼Œæ ¸å¿ƒçº¦æŸè¢«æ·¹æ²¡ |
| 88-90 | âš ï¸ ç¤ºä¾‹è¿‡äºç®€å• | ä¸­ | groupby+rollingåªæœ‰2è¡Œè¯´æ˜ï¼Œæ²¡æœ‰é”™è¯¯é¢„é˜² |
| 110-114 | âš ï¸ çº¦æŸé‡å¤ | ä½ | "ä¸¥ç¦"éƒ¨åˆ†ä¸æ¨¡æ¿ä¸­çš„çº¦æŸé‡å¤ |
| 119-182 | âŒ ä¿¡æ¯è¿‡è½½ | é«˜ | æ•°æ®åŠ è½½è§„èŒƒé•¿è¾¾63è¡Œï¼ŒåŒ…å«å¤§é‡ç»†èŠ‚ |
| 156-183 | âš ï¸ å†—ä½™å†…å®¹ | ä¸­ | static_factors.parquetçš„ä½¿ç”¨è¯´æ˜è¿‡äºè¯¦ç»† |
| 184-197 | âš ï¸ å†—ä½™å†…å®¹ | ä¸­ | é¢„è®¡ç®—å› å­è¡¨çš„è¯´æ˜ä¸å› å­ç¼–ç æ— å…³ |

**ä¸ºä½•ä¸åˆç†**ï¼š
1. **ä¿¡æ¯è¿‡è½½**ï¼šæ ¸å¿ƒçº¦æŸï¼ˆMultiIndexã€åˆ—åé‡å‘½åã€è¾“å‡ºæ ¼å¼ï¼‰åˆ†æ•£åœ¨140è¡Œä¸­ï¼ŒLLMéš¾ä»¥èšç„¦
2. **ç¼ºå°‘é”™è¯¯é¢„é˜²**ï¼šæ²¡æœ‰é’ˆå¯¹groupby+rollingã€åˆ—åæ··æ·†ç­‰å¸¸è§é”™è¯¯çš„é¢„é˜²æªæ–½
3. **å†—ä½™å†…å®¹**ï¼šåŒ…å«å¤§é‡ä¸å› å­ç¼–ç æ— å…³çš„ä¿¡æ¯ï¼ˆé¢„è®¡ç®—å› å­è¡¨ã€æ•°æ®é›†è¯´æ˜ç­‰ï¼‰

---

### 2.3 scenarios/qlib/experiment/prompts.yaml - qlib_factor_experiment_settingï¼ˆå¸¦é—®é¢˜æ ‡æ³¨ï¼‰

```yaml
qlib_factor_experiment_setting: |-
  | Dataset ğŸ“Š | Model ğŸ¤–    | Factors ğŸŒŸ       | Data Split  ğŸ§®                                   |
  |---------|----------|---------------|-------------------------------------------------|
  | AIstock A-share (non-ST, non-delisted)  | GRU_TimeSeries_Model | Alpha158 Plus + AIstock factors | Train: 2010-01-07 to 2018-12-31 <br> Valid: 2019-01-01 to 2020-12-31 <br> Test &nbsp;: 2021-01-01 to 2025-12-01 |
  
  **é‡è¦è¯´æ˜ï¼šè‚¡ç¥¨ä»£ç æ ¼å¼**
  - è™½ç„¶æ•°æ®é›†åç§°ä¸º "AIstock A-share"ï¼Œä½†æ‰€æœ‰åŸå§‹ HDF5/Parquet æ•°æ®ä¸­çš„ `instrument` å‡å·²ç»Ÿä¸€ä¸º **Qlib é£æ ¼**ï¼ˆå¦‚ `000001.SZ`, `600000.SH`ï¼‰ã€‚
  - **ç¦æ­¢**åœ¨å› å­è„šæœ¬ä¸­è¿›è¡Œä»»ä½•å½¢å¼çš„æ ¼å¼è½¬æ¢é€»è¾‘.
  
  #### è®¡ç®—èµ„æºä¸è®­ç»ƒè´Ÿè½½å»ºè®®ï¼ˆè¯·ä¼˜å…ˆæ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼Œä»¥å……åˆ†åˆ©ç”¨æœ¬æœº 12 æ ¸ 24 çº¿ç¨‹ + GPUï¼‰
  - **è®­ç»ƒè½®æ•°ä¸ batch å¤§å°**ï¼š
    - å¯¹äºä¸»è¦å®éªŒï¼Œè¯·é¿å…ä½¿ç”¨è¿‡å°é…ç½®ï¼ˆå¦‚ `n_epochs < 100`ã€`batch_size < 256`ï¼‰ã€‚
    - æ¨èé…ç½®èŒƒå›´ï¼š`n_epochs` åœ¨ `200~300`ï¼›`batch_size` ä»¥ `512` ä¸ºä¼˜å…ˆï¼ˆå¦‚æ˜¾å­˜ä¸è¶³å¯é™åˆ° `256`ï¼‰ã€‚
  - **å¹¶è¡Œåº¦è®¾ç½®ï¼ˆCPUï¼‰**ï¼š
    - å¯¹æ”¯æŒ `n_jobs` çš„æ¨¡å‹æˆ–æ•°æ®å¤„ç†ç»„ä»¶ï¼Œä¼˜å…ˆè®¾ç½®ä¸º `n_jobs: 12`ï¼ˆæ¥è¿‘ç‰©ç†æ ¸å¿ƒæ•°ï¼‰ã€‚
    - å¦‚ YAML ä¸­å­˜åœ¨ `workers` / `num_workers` / `processes` ç­‰å­—æ®µï¼Œå¯è®¾ç½®åœ¨ `8~12` ä¹‹é—´ï¼Œé¿å…è¿œé«˜äº CPU æ ¸å¿ƒæ•°ã€‚
  - **GPU ä½¿ç”¨**ï¼š
    - å¯¹åŸºäº PyTorch çš„æ—¶åºæ¨¡å‹ï¼ˆå¦‚ `GRU_TimeSeries_Model`ï¼‰ï¼Œå¿…é¡»ä¿è¯ `use_GPU: True`ï¼Œ`device: "cuda:0"`ï¼Œç¦æ­¢éšæ„æ”¹æˆ `cpu`ã€‚
  - **é“¾è·¯ç¨³å®šä¼˜å…ˆ**ï¼š
    - åœ¨åŠ å¤§è®­ç»ƒè´Ÿè½½å‰ï¼Œå…ˆç”¨è¾ƒå°å¾ªç¯ï¼ˆå¦‚ `--loop-n 1`ï¼‰ç¡®è®¤æ•´æ¡å› å­ä¸ Qlib è®­ç»ƒé“¾è·¯å®Œå…¨æ‰“é€šï¼š
      - ä½¿ç”¨ snapshot ä¸­å®é™…å­˜åœ¨ä¸”å¯ç”¨çš„è‚¡ç¥¨æ± ï¼ˆé€šå¸¸ä¸º `instruments: all`ï¼‰ã€‚
      - æ‰€æœ‰å› å­èƒ½åœ¨ `daily_pv.h5` ä¸ŠæˆåŠŸè®¡ç®—å¹¶ç”Ÿæˆ `result.h5`ã€‚
  - åªæœ‰åœ¨æ•´æ¡æµæ°´çº¿ä¸å†å‡ºç° `$close` / è‚¡ç¥¨æ± ä¸å­˜åœ¨ç­‰åŸºç¡€æŠ¥é”™åï¼Œæ‰é€æ­¥å¢åŠ  `n_epochs`ã€`batch_size` ä¸å¹¶è¡Œåº¦ã€‚
  
  #### è‚¡ç¥¨æ± ç­›é€‰ä¸æ¯æ—¥æŒ‡æ ‡å› å­çš„ä¼˜å…ˆä½¿ç”¨åŸåˆ™
  - åœ¨å› å­ä¸ç­–ç•¥æ¼”è¿›è¿‡ç¨‹ä¸­ï¼Œ**ä¼˜å…ˆä½¿ç”¨é¢„è®¡ç®—çš„ daily_basic å› å­è¡¨ï¼ˆä¼°å€¼ã€å¸‚å€¼ã€æµåŠ¨æ€§ç­‰ï¼‰åšç¨³å¥åŒ–ä¸é£é™©æ§åˆ¶**ï¼Œå†åœ¨ç›¸å¯¹"å¯äº¤æ˜“/å¯è§£é‡Š"çš„æ ·æœ¬ä¸Šè¿›è¡Œå¤šå› å­å»ºæ¨¡ä¸é€‰è‚¡ï¼š
    - ä¼˜å…ˆç”¨äºï¼šæš´éœ²æ§åˆ¶ï¼ˆè§„æ¨¡/æµåŠ¨æ€§ï¼‰ã€winsorize/clipã€åˆ†å±‚/åˆ†ç»„ä¸­æ€§åŒ–ã€ä»¥åŠå¯¹æç«¯å°¾éƒ¨æ ·æœ¬çš„æƒ©ç½šï¼ˆè¿‡æ»¤åº”ä½œä¸ºæœ€åæ‰‹æ®µï¼‰ï¼›
    - åœ¨åŠ å…¥æ–°å› å­å‰ï¼Œå…ˆç¡®ä¿åŸºç¡€å› å­é›†åœ¨ IC ä¸å›æµ‹ç¨³å®šæ€§ä¸Šä¸å†å‡ºç°ç³»ç»Ÿæ€§å´©åï¼ˆä¾‹å¦‚å…¨ NaN æˆ–æ˜¾è‘—è´Ÿæ”¶ç›Šï¼‰ã€‚
  
  #### ç­–ç•¥æ¼”è¿›ä¼˜å…ˆçº§ï¼ˆå½“ IC è¿ç»­ä¸º NaN æˆ–æ”¶ç›Šæ˜¾è‘—ä¸ºè´Ÿæ—¶ï¼‰
  - è‹¥æœ€è¿‘è‹¥å¹²è½®å®éªŒä¸­ï¼Œ**æ¨ªæˆªé¢ IC å¤§å¤šä¸º NaN/æ¥è¿‘ 0ï¼Œä¸”ç»„åˆå¹´åŒ–æ”¶ç›Šæ˜æ˜¾ä¸ºè´Ÿã€æœ€å¤§å›æ’¤è¿‡å¤§**ï¼Œè¯·ä¼˜å…ˆæ’æŸ¥å¹¶æ¼”è¿›ä»¥ä¸‹æ–¹å‘ï¼Œè€Œä¸æ˜¯ç›²ç›®æ›´æ¢æ›´å¤æ‚çš„æ—¶é—´åºåˆ—ç»“æ„ï¼š
    1. **å…ˆä¿®å› å­ä¸æ ‡ç­¾ï¼ˆä¿¡å·è´¨é‡ä¼˜å…ˆï¼‰**ï¼š
       - æ£€æŸ¥å› å­æ˜¯å¦è¿‘ä¼¼å¸¸æ•°ã€æ˜¯å¦è¿‡åº¦ç¨€ç–ã€æ˜¯å¦å› å¯¹é½/merge/dropna å¯¼è‡´æœ‰æ•ˆæ ·æœ¬å´©å¡Œï¼›
       - æ£€æŸ¥å¹¶ä¼˜åŒ–æ ‡ç­¾ï¼šåˆç†é€‰æ‹©é¢„æµ‹çª—å£ï¼ˆä¾‹å¦‚ 1D/5D/10D æ”¶ç›Šï¼‰ï¼Œå¹¶æ˜ç¡®æ˜¯ç»å¯¹æ”¶ç›Šè¿˜æ˜¯è¶…é¢æ”¶ç›Šï¼Œç¡®ä¿è¯„ä¼°æŒ‡æ ‡ä¸æ ‡ç­¾å£å¾„ä¸€è‡´ã€‚
    2. **ç”¨åŸºç¡€å› å­åšç¨³å¥åŒ–ä¸é£é™©ç”¨é€”**ï¼š
       - `daily_basic`ï¼ˆä¼°å€¼/å¸‚å€¼/æµåŠ¨æ€§ï¼‰ä¼˜å…ˆç”¨äºæš´éœ²æ§åˆ¶ä¸ç¨³å®šæ€§çº¦æŸï¼ˆå¿…è¦æ—¶æ‰åšè¿‡æ»¤ï¼‰ï¼›
       - `ae_recon_error_10d` æ›´é€‚åˆä½œä¸ºå¼‚å¸¸æ£€æµ‹/é£é™©å› å­å‚ä¸æƒ©ç½šæˆ–è¿‡æ»¤ï¼Œè€Œä¸æ˜¯å•ç‹¬æ‰¿æ‹…ä¸»è¦é€‰è‚¡ä¿¡å·.
    3. **æ§åˆ¶å› å­æ•°é‡ä¸ç›¸å…³æ€§ï¼Œå…ˆè·‘ç¨³ Tabular åŸºçº¿**ï¼š
       - é¿å…å¤§é‡é«˜åº¦å…±çº¿æˆ–æåº¦ç¨€ç–çš„æ–°å› å­ï¼›
       - å…ˆåœ¨ LightGBM / CatBoost / ç®€å• MLP ç­‰ Tabular åŸºçº¿ä¸‹éªŒè¯ IC ä¸å†ä¸º NaN ä¸”æ”¶ç›Šä¸å†ç³»ç»Ÿæ€§ä¸ºè´Ÿï¼Œå†è€ƒè™‘å¼•å…¥æ›´å¤æ‚çš„æ—¶åºç»“æ„.
```

**é—®é¢˜æ ‡æ³¨**ï¼š

| è¡Œå· | é—®é¢˜ | ä¸¥é‡åº¦ | è¯´æ˜ |
|------|------|--------|------|
| 311-313 | âœ… æ•°æ®é›†ä¿¡æ¯ | ä½ | ä¿ç•™ï¼Œå› å­ç¼–ç éœ€è¦çŸ¥é“æ•°æ®é›† |
| 316-318 | âœ… è‚¡ç¥¨ä»£ç æ ¼å¼ | ä½ | ä¿ç•™ï¼Œé‡è¦çº¦æŸ |
| 320-333 | âŒ å†—ä½™å†…å®¹ | é«˜ | è®­ç»ƒè´Ÿè½½å»ºè®®ä¸å› å­ç¼–ç æ— å…³ |
| 335-338 | âŒ å†—ä½™å†…å®¹ | é«˜ | è‚¡ç¥¨æ± ç­›é€‰åŸåˆ™ä¸å› å­ç¼–ç æ— å…³ |
| 340-350 | âŒ å†—ä½™å†…å®¹ | é«˜ | ç­–ç•¥æ¼”è¿›ä¼˜å…ˆçº§ä¸å› å­ç¼–ç æ— å…³ |

**ä¸ºä½•ä¸åˆç†**ï¼š
1. **å†—ä½™å†…å®¹**ï¼šåŒ…å«å¤§é‡ä¸å› å­ç¼–ç æ— å…³çš„ä¿¡æ¯ï¼ˆæ¨¡å‹è®­ç»ƒã€ç­–ç•¥æ¼”è¿›ã€ç¡¬ä»¶é…ç½®ï¼‰
2. **ä¿¡æ¯è¿‡è½½**ï¼šå› å­ç¼–ç æç¤ºè¯ä¸­æ··å…¥äº†æ¨¡å‹è®­ç»ƒå’Œç­–ç•¥å»ºè®®
3. **èŒè´£ä¸æ¸…**ï¼šè¿™äº›ä¿¡æ¯åº”è¯¥åœ¨`model_coder`æˆ–`proposal`æç¤ºè¯ä¸­

---

## ä¸‰ã€å»ºè®®çš„æ‹†åˆ†ç‰ˆæœ¬

### 3.1 æ–‡ä»¶ç»“æ„

```
rdagent/
â”œâ”€â”€ components/
â”‚   â””â”€â”€ coder/
â”‚       â””â”€â”€ factor_coder/
â”‚           â”œâ”€â”€ prompts.yaml                              # ä¸»æç¤ºè¯ï¼ˆç»„åˆå„æ¨¡å—ï¼‰
â”‚           â”œâ”€â”€ prompts_core_constraints.yaml             # æ ¸å¿ƒçº¦æŸ
â”‚           â”œâ”€â”€ prompts_error_prevention.yaml             # é”™è¯¯é¢„é˜²
â”‚           â”œâ”€â”€ prompts_examples.yaml                     # å®Œæ•´ç¤ºä¾‹
â”‚           â”œâ”€â”€ prompts_language_spec.yaml                # è¯­è¨€è§„èŒƒ
â”‚           â””â”€â”€ prompts_dataset_info.yaml                 # æ•°æ®é›†ä¿¡æ¯
```

### 3.2 prompts_core_constraints.yamlï¼ˆæ ¸å¿ƒçº¦æŸï¼‰

```yaml
factor_coder_core_constraints: |-
  ã€æ ¸å¿ƒçº¦æŸï¼ˆå¿…é¡»ä¸¥æ ¼éµå®ˆï¼‰ã€‘
  
  1. ç´¢å¼•ç»“æ„
     - å¿…é¡»å§‹ç»ˆä¿æŒ MultiIndex(datetime, instrument)
     - ç¦æ­¢ï¼šreset_index(drop=True)ã€droplevel()ã€swaplevel() ç­‰æ”¹å˜ç´¢å¼•ç»“æ„çš„æ“ä½œ
     - è¾“å‡ºæ—¶å¿…é¡»ï¼šresult_df.index.names = df.index.names
  
  2. åˆ—åè§„èŒƒ
     - å¿…é¡»å…ˆç»Ÿä¸€é‡å‘½åï¼Œåç»­åªä½¿ç”¨é‡å‘½ååçš„å­—æ®µ
     - ç¦æ­¢ï¼šæ··ç”¨ $close å’Œ close
     - å¿…é¡»ï¼š
       ```python
       rename_map = {
           "$open": "open", "$close": "close", "$high": "high",
           "$low": "low", "$volume": "volume", "$amount": "amount", "$factor": "factor"
       }
       df = df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns})
       ```
  
  3. è¾“å‡ºæ ¼å¼
     - å¿…é¡»ä½¿ç”¨ï¼šresult_df = pd.DataFrame(index=df.index)

---

## å››ã€Loop 8-9 æç¤ºè¯é”™é…é—®é¢˜çš„è®¾è®¡å±‚é¢æ€»ç»“

### 4.1 é—®é¢˜å›é¡¾ï¼šä¸ºä»€ä¹ˆåœ¨æ¨¡å‹é˜¶æ®µçœ‹åˆ°äº†å› å­ coding æç¤ºè¯ï¼Ÿ

- åœ¨ QlibQuant åœºæ™¯ä¸‹ï¼Œå¤–å±‚ RD-Loop çš„â€œæ–¹å‘â€æ˜¯ç”± `Hypothesis.action âˆˆ {factor, model}` å†³å®šçš„ï¼š
  - `action="factor"` â†’ èµ°å› å­ç ”å‘/å› å­å®éªŒï¼ˆå› å­ coder + å› å­ evaluatorï¼‰
  - `action="model"` â†’ èµ°æ¨¡å‹ç ”å‘/æ¨¡å‹å®éªŒï¼ˆæ¨¡å‹ coder + æ¨¡å‹ evaluatorï¼‰
- åœ¨ 2026-01-12 è¿™æ¬¡æ—¥å¿—ä¸­ï¼š
  - Loop 7 çš„ Hypothesis.action = `factor`ï¼ˆæ­£å¸¸å› å­å›åˆï¼‰
  - Loop 8 çš„ Hypothesis.action = `model`ï¼ˆæ­£å¸¸æ¨¡å‹å›åˆï¼ŒGRU+Attention å‡è®¾ï¼‰
  - Loop 9 çš„ Hypothesis.action = `factor`ï¼ˆè¢« Bandit å†³ç­–ä» model åˆ‡å› factorï¼‰
- ç»“æœæ˜¯ï¼š
  - **å†…éƒ¨ç»„ä»¶å·²ç»æŒ‰ `action=factor` åˆ‡æ¢åˆ°å› å­ coder / å› å­ evaluatorï¼Œæç¤ºè¯ä¹Ÿåˆ‡åˆ°äº†å› å­é‚£ä¸€å¥—**ï¼›
  - ä½†ä¸Šå±‚æŸäº›è§£æé€»è¾‘ä»ç„¶æŒ‰â€œè¿™æ˜¯æ¨¡å‹è¯„åˆ†è½®æ¬¡â€å‡å®š LLM ä¼šè¿”å› `{final_decision, final_feedback}`ï¼›
  - å®é™…æ‹¿åˆ°çš„å´æ˜¯å› å­ / coding é£æ ¼çš„è¾“å‡ºï¼ˆä¾‹å¦‚åªåŒ…å« `code`ï¼‰ï¼Œä»è€Œåœ¨è®¿é—® `final_decision` æ—¶ç¨³å®šè§¦å‘ `KeyError`ã€‚

å› æ­¤ï¼Œè¡¨é¢ç°è±¡æ˜¯â€œåœ¨æ¨¡å‹è¯„åˆ†é˜¶æ®µå‡ºç°äº†å› å­ coding æç¤ºè¯â€ï¼Œ
æœ¬è´¨æ˜¯ï¼š**çŠ¶æ€æœº/åˆ†æ”¯æ§åˆ¶æ²¡æœ‰å¯¹ `action` ä¸è°ƒç”¨é“¾åšç¡¬çº¦æŸï¼Œå¯¼è‡´â€œæ‰§è¡Œçš„ä»»åŠ¡çº¿â€å’Œâ€œæ¶ˆè´¹ç»“æœçš„é€»è¾‘â€ä¸ä¸€è‡´ã€‚**

### 4.2 å“ªäº›å±äºç¨‹åºé€»è¾‘è®¾è®¡é—®é¢˜ï¼Ÿ

ä»æ¶æ„è§†è§’çœ‹ï¼Œä»¥ä¸‹å‡ ç‚¹å±äº **éœ€è¦ä¿®æ”¹ rdagent æ ¸å¿ƒä»£ç ** æ‰èƒ½çœŸæ­£æ ¹æ²»çš„é—®é¢˜ï¼š

- **(1) ç¼ºå°‘æ˜¾å¼çš„ TaskState/PhaseState æ¦‚å¿µ**
  - ç›®å‰â€œç°åœ¨æ˜¯ä¸æ˜¯æ¨¡å‹è¯„ä¼°é˜¶æ®µâ€æ›´å¤šæ˜¯è°ƒç”¨æ–¹çš„ä¸»è§‚å‡è®¾ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªæ˜¾å¼çš„ `TaskState` å¯¹è±¡ï¼›
  - è®¾è®¡ä¸Šåº”å½“æœ‰ç±»ä¼¼ï¼š
    - `TaskState.loop_id`
    - `TaskState.phase âˆˆ {propose, coding, evaluate, backtest, ...}`
    - `TaskState.action âˆˆ {factor, model}`
    - `TaskState.task_type âˆˆ {FactorTask, ModelTask}`
  - æ‰€æœ‰ evaluator / coder / runner éƒ½åº”æ˜¾å¼ä¾èµ–è¿™ä¸ªçŠ¶æ€ï¼Œè€Œä¸æ˜¯è‡ªå·±çŒœå½“å‰é˜¶æ®µã€‚

- **(2) è°ƒç”¨ evaluator å‰æ²¡æœ‰å¼ºåˆ¶æ£€æŸ¥ action / phase / task_type ä¸€è‡´æ€§**
  - ç†æƒ³è®¾è®¡ï¼š
    - `ModelFinalEvaluator.evaluate(model_task, state)` å¿…é¡»åœ¨ `state.phase == "evaluate" && state.action == "model"` æ—¶æ‰å…è®¸è¢«è°ƒç”¨ï¼›
    - `FactorFinalDecisionEvaluator.evaluate(factor_task, state)` å¿…é¡»åœ¨ `state.phase == "evaluate" && state.action == "factor"` æ—¶æ‰å…è®¸è¢«è°ƒç”¨ï¼›
  - å½“å‰å®ç°ä¸­ï¼ŒModel evaluator åœ¨è§£æ LLM è¿”å› JSON æ—¶ç›´æ¥è®¿é—® `final_decision`ï¼Œå¹¶æ²¡æœ‰å…ˆç¡®è®¤ï¼š
    - å½“å‰è¿™è½®çš„ Hypothesis.action æ˜¯å¦ä¸º `model`ï¼›
    - å½“å‰ä½¿ç”¨çš„ system prompt æ˜¯å¦çœŸçš„æ˜¯â€œæ¨¡å‹è¯„ä¼° promptâ€ã€‚

- **(3) Prompt é€‰æ‹©é€»è¾‘æ²¡æœ‰ç»Ÿä¸€é€šè¿‡ Selector ä¸çŠ¶æ€ç»‘å®š**
  - æ›´åˆç†çš„è®¾è®¡åº”å½“æœ‰ç»Ÿä¸€çš„ `PromptSelector`ï¼š
    - `select_prompt(role, phase, action, task_type) -> prompt_key`
  - æ‰€æœ‰ç»„ä»¶é€šè¿‡ Selector æ‹¿ prompt keyï¼ŒSelector å†…éƒ¨å¯ä»¥åœ¨çŠ¶æ€ä¸ä¸€è‡´æ—¶ç›´æ¥æŠ¥é”™ï¼š
    - å¦‚ `role="evaluator"`, `task_type=ModelTask`, `action="factor"` æ—¶æ‹’ç»è¿”å›â€œæ¨¡å‹è¯„ä¼° promptâ€ã€‚

- **(4) Bandit/LLM å†³ç­–ä¸æ‰§è¡Œæ¨¡å—ä¹‹é—´ç¼ºå°‘ handshake/contract**
  - Bandit ç›®å‰å¯ä»¥â€œé»‘ç›’åœ°â€ä¿®æ”¹ä¸‹ä¸€è½®çš„ `action`ï¼Œå¤–å±‚å¹¶æ²¡æœ‰ä¸€ä¸ªæ˜¾å¼çš„ `ActionDecision` å¥‘çº¦ï¼›
  - è®¾è®¡ä¸Šåº”å½“å¼•å…¥ï¼š
    - `ActionDecision.decided_action`
    - `ActionDecision.reason`
    - `ActionDecision.confidence`
    - `ActionDecision.allowed_phases`
  - æ‰§è¡Œæ¨¡å—åœ¨åº”ç”¨è¿™ä¸ªå†³ç­–ä¹‹å‰ï¼Œéœ€è¦æ ¡éªŒå½“å‰ `TaskState.phase` æ˜¯å¦å…è®¸åˆ‡æ¢åˆ°è¯¥ actionï¼Œå¦åˆ™è¦ä¹ˆæ‹’ç»ã€è¦ä¹ˆåšæ˜¾å¼é™çº§å¤„ç†ï¼Œè€Œä¸æ˜¯é™é»˜åˆ‡æ¢å¯¼è‡´åç»­é“¾è·¯é”™ä½ã€‚

> ä»¥ä¸Š 4 ç‚¹æ¶‰åŠçŠ¶æ€æœºã€æ¥å£å¥‘çº¦ã€ç»„ä»¶è°ƒç”¨å…³ç³»ï¼Œ**æ— æ³•ä»…é æç¤ºè¯è°ƒæ•´æ¥å½»åº•è§£å†³**ï¼Œéœ€è¦åœ¨ rdagent å†…éƒ¨åšä¸€å®šç¨‹åº¦çš„æ”¹é€ ã€‚

### 4.3 å•é æç¤ºè¯ä¿®æ”¹å¯ä»¥åšåˆ°ä»€ä¹ˆï¼Ÿ

åœ¨ä¸åŠ¨ rdagent æ ¸å¿ƒä»£ç çš„å‰æä¸‹ï¼Œæç¤ºè¯å±‚é¢å¯ä»¥åšçš„äº‹æƒ…ä¸»è¦æ˜¯ï¼š

- **(A) æç¤ºè¯å‘½åä¸å†…å®¹ä¸Šå¼ºåŒ–â€œè§’è‰²/é˜¶æ®µ/action è‡ªæè¿°â€**
  - åœ¨ system prompt ä¸­æ˜¾å¼åŠ å…¥å…ƒä¿¡æ¯ï¼Œä¾‹å¦‚ï¼š
    - `"ROLE": "evaluator", "PHASE": "final_decision", "ACTION": "model"`
  - è¦æ±‚ LLM åœ¨ JSON è¾“å‡ºä¸­åŸæ · echo è¿™äº›å­—æ®µï¼š
    ```json
    {
      "ROLE": "evaluator",
      "PHASE": "final_decision",
      "ACTION": "model",
      "final_decision": true,
      "final_feedback": "..."
    }
    ```
  - è¿™æ ·ä¸€æ—¦åœ¨æ—¥å¿—åˆ†æ/å¤–æŒ‚è„šæœ¬ä¸­å‘ç° `ACTION` ä¸æœŸæœ›ä¸ç¬¦ï¼Œå¯ä»¥åœ¨å¤–å±‚ fail-fastï¼Œè€Œä¸æ˜¯ç­‰åˆ° KeyError æ‰çŸ¥é“é”™äº†ã€‚

- **(B) å¯¹ Bandit/LLM å†³ç­–ç±» prompt æ˜ç¡®â€œä½•æ—¶å¯ä»¥/ä¸å¯ä»¥åˆ‡æ¢æ–¹å‘â€**
  - åœ¨ `action_gen.system` / `action_gen.user` æç¤ºè¯ä¸­åŠ å…¥è§„åˆ™ï¼š
    - å½“å¤„äºâ€œæ¨¡å‹æ”¶æ•›é˜¶æ®µï¼ˆä¾‹å¦‚ Loop 8-10ï¼‰â€æ—¶ï¼Œé™¤éæœ‰å¼ºè¯æ®ï¼Œå¦åˆ™å°½é‡ä¸è¦ä» model åˆ‡å› factorï¼›
    - å¦‚æœä¸Šä¸€è½®å¤±è´¥æ˜¯ç”±äºå®ç°é”™è¯¯ï¼ˆç¼–ç /è¿è¡Œé”™è¯¯ï¼‰ï¼Œåº”ä¼˜å…ˆç»™å½“å‰æ–¹å‘å†ä¸€æ¬¡æœºä¼šï¼›
  - è¿™æ ·å¯ä»¥ **é™ä½** 8â†’9 çªç„¶ä» model åˆ‡å› factor çš„æ¦‚ç‡ï¼Œä»è€Œå‡å°‘æç¤ºè¯ä¸æœŸæœ›é˜¶æ®µä¸ä¸€è‡´çš„æƒ…å†µã€‚

- **(C) åœ¨ evaluator æç¤ºè¯ä¸­è¦æ±‚ LLM è‡ªæ£€è¾“å‡ºç»“æ„**
  - ä¾‹å¦‚åœ¨å› å­/æ¨¡å‹è¯„ä¼°æç¤ºè¯ä¸­å¼ºè°ƒï¼š
    - â€œå¦‚æœä½ æ— æ³•ç»™å‡º `final_decision`ï¼Œå¿…é¡»æ˜¾å¼è¿”å› `"error_type": "no_final_decision"`ï¼Œè€Œä¸æ˜¯è¿”å› `code` å­—æ®µâ€ï¼›
  - ä¾¿äºå¤–å›´è„šæœ¬åœ¨è§£ææ—¶åŒºåˆ†ï¼š
    - æ˜¯ LLM è‡ªèº«æ²¡æŒ‰æ ¼å¼æ¥ï¼Œè¿˜æ˜¯ä¸Šä¸‹æ¸¸åˆ†æ”¯æœ¬èº«å°±é”™ä½äº†ã€‚

> è¿™äº›å±äºâ€œæç¤ºè¯çº§çš„é˜²å¾¡ä¸è‡ªæè¿°â€ï¼Œ**å¯ä»¥åœ¨ä¸æ”¹æ ¸å¿ƒä»£ç çš„å‰æä¸‹å¸®åŠ©è¯Šæ–­å’Œå‡è½»é—®é¢˜ï¼Œä½†æ— æ³•ä»æ ¹æœ¬ä¸Šä¿è¯ç»„ä»¶è°ƒç”¨é“¾å’ŒçŠ¶æ€æœºçš„ä¸€è‡´æ€§ã€‚**

### 4.4 ä½¿ç”¨ LLM å†³ç­–ï¼ˆaction_selection="llm"ï¼‰èƒ½å¦å•ç‹¬è§£å†³é—®é¢˜ï¼Ÿ

- å°† `action_selection` ä» `"bandit"` æ¢æˆ `"llm"` çš„æ•ˆæœï¼š
  - å¯ä»¥è®© LLM åœ¨é˜…è¯»å†å²å®éªŒåé¦ˆæ—¶ï¼Œæ›´æ™ºèƒ½åœ°åˆ¤æ–­â€œè¦ä¸è¦ç»§ç»­æ¨¡å‹æ–¹å‘â€ï¼Œä»è€Œ **å‡å°‘** 8â†’9 è¿™ç§æç«¯åˆ‡æ¢çš„æ¦‚ç‡ï¼›
  - å°¤å…¶æ˜¯åœ¨ä¸Šä¸€è½®å¤±è´¥æ˜¯â€œå®ç°é”™è¯¯â€è€Œéâ€œæ¨¡å‹æ€è·¯é”™è¯¯â€æ—¶ï¼ŒLLM æ›´æœ‰æœºä¼šåšå‡ºâ€œç»§ç»­å°è¯•æ¨¡å‹â€çš„å†³ç­–ã€‚
- ä½†ä»è®¾è®¡ä¸Šçœ‹ï¼ŒLLM åªè´Ÿè´£â€œ**é€‰æ–¹å‘**â€ï¼Œä¸è´Ÿè´£ï¼š
  - è°æ¥æ¶ˆè´¹è¿™æ¬¡ LLM çš„è¾“å‡ºï¼ˆå“ªä¸€ä¸ª evaluator/coderï¼‰ï¼›
  - ä»¥åŠæ¶ˆè´¹æ—¶ç”¨ä»€ä¹ˆè§£æé€»è¾‘ã€è§£æå‰æ˜¯å¦æ£€æŸ¥ `action/ROLE/PHASE`ã€‚

**ç»“è®º**ï¼š

- æ¢æˆ LLM å†³ç­–æ¨¡å¼å¯ä»¥ï¼š
  - âœ… é™ä½é”™è¯¯åˆ‡æ¢ `action` çš„é¢‘ç‡ï¼›
  - âœ… æé«˜å†³ç­–å¯è§£é‡Šæ€§ï¼ˆå¯ä»¥åœ¨æ—¥å¿—é‡Œçœ‹åˆ° LLM çš„å†³ç­–ç†ç”±ï¼‰ã€‚
- ä½†ä¸èƒ½å•ç‹¬è§£å†³ï¼š
  - âŒ `Hypothesis.action` ä¸å®é™…è¢«è°ƒç”¨çš„ evaluator/coder ä¸ä¸€è‡´çš„é—®é¢˜ï¼›
  - âŒ evaluator åœ¨ä¸æ£€æŸ¥çŠ¶æ€å’Œ prompt ç±»å‹çš„å‰æä¸‹å¼ºè¡Œè§£æ `final_decision` çš„ç»“æ„æ€§é£é™©ã€‚

### 4.5 æ€»ç»“ï¼šè®¾è®¡å±‚é¢çš„â€œå¿…é¡»æ”¹ä»£ç â€ vs â€œå¯é æç¤ºè¯ç¼“è§£â€

| ç±»åˆ« | å†…å®¹ | æ˜¯å¦å¿…é¡»åŠ¨æ ¸å¿ƒä»£ç  | ä½œç”¨ |
|------|------|--------------------|------|
| çŠ¶æ€å»ºæ¨¡ | æ˜¾å¼ TaskState/PhaseStateï¼ˆphase/action/task_typeï¼‰ | âœ… æ˜¯ | ä»æ¶æ„ä¸Šçº¦æŸâ€œè°å¯ä»¥è°ƒç”¨è°â€ |
| æ¥å£å¥‘çº¦ | evaluator/coder æ¥å£å¼ºåˆ¶æ£€æŸ¥ `action` ä¸ `phase` | âœ… æ˜¯ | é˜²æ­¢åœ¨é”™è¯¯çŠ¶æ€ä¸‹è°ƒç”¨é”™è¯¯ç»„ä»¶ |
| PromptSelector | é€šè¿‡ (role, phase, action, task_type) ç»Ÿä¸€é€‰æ‹© prompt key | âœ… æ˜¯ | ä»æ ¹ä¸Šé¿å…â€œç»„ä»¶â€“prompt é”™é…â€ |
| å†³ç­– handshake | Bandit/LLM è¾“å‡º ActionDecisionï¼Œæ‰§è¡Œå‰åš allowed_phases æ ¡éªŒ | âœ… æ˜¯ | é˜²æ­¢åœ¨ä¸å…è®¸çš„é˜¶æ®µé™é»˜åˆ‡æ¢æ–¹å‘ |
| Prompt è‡ªæè¿° | åœ¨ system prompt/JSON ä¸­åŠ å…¥ ROLE/PHASE/ACTION å­—æ®µ | âŒ å¦ï¼ˆä»…æ”¹ YAMLï¼‰ | ä¾¿äºæ—¥å¿—è¯Šæ–­ä¸å¤–æŒ‚æ ¡éªŒ |
| å†³ç­–æç¤ºè¯çº¦æŸ | åœ¨ action_gen æç¤ºè¯ä¸­åŠ å…¥â€œä½•æ—¶å…è®¸åˆ‡æ¢æ–¹å‘â€çš„è§„åˆ™ | âŒ å¦ | é™ä½é”™è¯¯åˆ‡æ¢ action çš„æ¦‚ç‡ |
| LLM å†³ç­–æ›¿ä»£ Bandit | å°† action_selection æ”¹ä¸º "llm" | âŒ å¦ | ç¼“è§£ï¼Œä½†ä¸èƒ½æ ¹æ²»ç»“æ„é—®é¢˜ |

æœ¬èŠ‚çš„ç»“è®ºæ˜¯ï¼š

- **æ ¹å› åœ¨äº RD-Agent å†…éƒ¨çŠ¶æ€æœºä¸ç»„ä»¶è°ƒç”¨ç¼ºå°‘ç¡¬çº¦æŸï¼Œè¿™æ˜¯å¿…é¡»é€šè¿‡ä¿®æ”¹æ ¸å¿ƒä»£ç æ‰èƒ½å½»åº•è§£å†³çš„è®¾è®¡é—®é¢˜ï¼›**
- **æç¤ºè¯å±‚é¢çš„æ‹†åˆ†ä¸å¼ºåŒ–ï¼ˆåŒ…æ‹¬å› å­/æ¨¡å‹èŒè´£æ‹†åˆ†ã€ROLE/PHASE/ACTION è‡ªæè¿°ã€action_gen çº¦æŸç­‰ï¼‰ï¼Œå¯ä»¥ä½œä¸ºåœ¨ä¸åŠ¨æ ¸å¿ƒä»£ç å‰æä¸‹çš„â€œç¼“è§£ä¸è¯Šæ–­æ–¹æ¡ˆâ€ï¼Œä½†æ— æ³•å•ç‹¬ä¿è¯æ‰€æœ‰ Loop/é˜¶æ®µä¸‹æç¤ºè¯ä¸æ‰§è¡Œä»»åŠ¡ 100% ä¸€è‡´ã€‚**

     - å¿…é¡»ä½¿ç”¨ï¼šresult_df.index.names = df.index.names
     - ç¦æ­¢ï¼šresult_df.index.names = ["datetime", "instrument"]
     - å¿…é¡»è¾“å‡ºï¼šfloat32 ç±»å‹çš„å› å­å€¼
     - å¿…é¡»ä¿å­˜ï¼šresult.h5
  
  4. groupby+rolling
     - å¿…é¡»ï¼šåœ¨ groupby+rolling åä½¿ç”¨ reset_index(level=0, drop=True)
     - åŸå› ï¼šgroupby+rolling åç´¢å¼•å˜æˆ (datetime, instrument, level_2)
     - ç¤ºä¾‹ï¼š
       ```python
       series = df["close"].groupby(level="instrument").rolling(window=10).mean()
       series = series.reset_index(level=0, drop=True)  # å…³é”®ï¼æ¢å¤ç´¢å¼•
       ```
  
  5. å¼‚å¸¸å¤„ç†
     - ç¦æ­¢ï¼šç”¨ try-except åŒ…è£¹æ•´ä¸ªä¸»é€»è¾‘
     - å…è®¸ï¼šåœ¨æå°‘æ•°éœ€è¦ç²¾ç»†å¤„ç†çš„å±€éƒ¨é€»è¾‘ä¸­ä½¿ç”¨å°èŒƒå›´ try-except
     - å¿…é¡»ï¼šé‡åˆ°ç¼ºå¤±å­—æ®µæ—¶ raise ValueError
  
  6. æ•°æ®åŠ è½½
     - åªèƒ½è¯»å–ï¼šdaily_pv.h5 å’Œ static_factors.parquet
     - å¿…é¡»ï¼šæŒ‰éœ€è¯»å– static_factors.parquetï¼Œç¦æ­¢å…¨é‡åŠ è½½
     - å¿…é¡»ï¼šæ£€æŸ¥åˆ—å­˜åœ¨æ€§ï¼Œç¦æ­¢ç¼–é€ å­—æ®µå
```

### 3.3 prompts_error_prevention.yamlï¼ˆé”™è¯¯é¢„é˜²ï¼‰

```yaml
factor_coder_error_prevention: |-
  ã€å¸¸è§é”™è¯¯é¢„é˜²ï¼ˆå¿…é¡»é˜…è¯»ï¼‰ã€‘
  
  [é”™è¯¯1] groupby+rolling ç´¢å¼•ä¸å¯¹é½
    é”™è¯¯ä»£ç ï¼š
      ```python
      corr = df.groupby(level="instrument")[["x", "y"]].rolling(window=10).corr()
      # é”™è¯¯ï¼šcorr çš„ç´¢å¼•æ˜¯ (datetime, instrument, level_2)ï¼Œä¸æ˜¯åŸå§‹ç´¢å¼•
      result_df = pd.DataFrame(index=df.index)
      result_df["corr"] = corr  # æŠ¥é”™ï¼šç´¢å¼•ä¸åŒ¹é…
      ```
    
    æ­£ç¡®ä»£ç ï¼š
      ```python
      corr = df.groupby(level="instrument")[["x", "y"]].rolling(window=10).corr()
      corr = corr.reset_index(level=0, drop=True)  # æ¢å¤ç´¢å¼•å¯¹é½
      result_df = pd.DataFrame(index=df.index)
      result_df["corr"] = corr  # æˆåŠŸ
      ```
    
    é”™è¯¯ä¿¡æ¯ï¼šValueError: cannot reindex on an axis with duplicate labels
    è§£å†³æ–¹æ¡ˆï¼šåœ¨ groupby+rolling åç«‹å³ä½¿ç”¨ reset_index(level=0, drop=True)
  
  [é”™è¯¯2] åˆ—åæ··æ·†
    é”™è¯¯ä»£ç ï¼š
      ```python
      df = pd.read_hdf("daily_pv.h5", key="data")
      # é”™è¯¯ï¼šç›´æ¥ä½¿ç”¨ $close
      close_price = df["$close"]  # å¯èƒ½æˆåŠŸï¼Œä½†ä¸åç»­ä»£ç ä¸ä¸€è‡´
      # åç»­åˆä½¿ç”¨ close
      volume = df["volume"]  # KeyError: 'volume'
      ```
    
    æ­£ç¡®ä»£ç ï¼š
      ```python
      df = pd.read_hdf("daily_pv.h5", key="data")
      rename_map = {"$open": "open", "$close": "close", "$volume": "volume"}
      df = df.rename(columns=rename_map)
      # åç»­åªä½¿ç”¨é‡å‘½ååçš„å­—æ®µ
      close_price = df["close"]
      volume = df["volume"]  # æˆåŠŸ
      ```
  
  [é”™è¯¯3] è¾“å‡ºæ ¼å¼é”™è¯¯
    é”™è¯¯ä»£ç ï¼š
      ```python
      result_df = pd.DataFrame({"factor": series})
      # é”™è¯¯ï¼šç´¢å¼•åç§°ä¸¢å¤±
      result_df.to_hdf("result.h5", key="data", mode="w")
      # åç»­åŠ è½½æ—¶ç´¢å¼•åç§°ä¸º Noneï¼Œå¯¼è‡´é—®é¢˜
      ```
    
    æ­£ç¡®ä»£ç ï¼š
      ```python
      result_df = pd.DataFrame(index=df.index)
      result_df["factor_name"] = series.astype("float32")
      result_df.index.names = df.index.names  # ç»§æ‰¿ç´¢å¼•åç§°
      result_df.to_hdf("result.h5", key="data", mode="w")
      ```
  
  [é”™è¯¯4] å…¨é‡åŠ è½½ static_factors.parquet
    é”™è¯¯ä»£ç ï¼š
      ```python
      # é”™è¯¯ï¼šå…¨é‡åŠ è½½ï¼Œå¯èƒ½å¯¼è‡´ OOM
      static_df = pd.read_parquet("static_factors.parquet")
      df = df.join(static_df, how="left")
      ```
    
    æ­£ç¡®ä»£ç ï¼š
      ```python
      # æ­£ç¡®ï¼šåªè¯»å–éœ€è¦çš„åˆ—
      required_static_cols = ["db_turnover_rate", "db_circ_mv"]
      static_df = pd.read_parquet("static_factors.parquet", columns=required_static_cols).sort_index()
      df = df.join(static_df, how="left")
      ```
  
  [é”™è¯¯5] ç¼–é€ å­—æ®µå
    é”™è¯¯ä»£ç ï¼š
      ```python
      # é”™è¯¯ï¼šç¼–é€ ä¸å­˜åœ¨çš„å­—æ®µå
      static_df = pd.read_parquet("static_factors.parquet", columns=["mf_net_inflow_1d"])
      # KeyError: "mf_net_inflow_1d" ä¸å­˜åœ¨
      ```
    
    æ­£ç¡®ä»£ç ï¼š
      ```python
      # æ­£ç¡®ï¼šåªä½¿ç”¨ schema ä¸­åˆ—å‡ºçš„å­—æ®µ
      required_static_cols = ["mf_lg_buy_amt", "mf_lg_sell_amt"]
      static_df = pd.read_parquet("static_factors.parquet", columns=required_static_cols).sort_index()
      # è‡ªè¡Œæ´¾ç”Ÿéœ€è¦çš„å­—æ®µ
      static_df["mf_net_inflow"] = static_df["mf_lg_buy_amt"] - static_df["mf_lg_sell_amt"]
      ```
```

### 3.4 prompts_examples.yamlï¼ˆå®Œæ•´ç¤ºä¾‹ï¼‰

```yaml
factor_coder_examples: |-
  ã€å®Œæ•´ç¤ºä¾‹ã€‘
  
  ç¤ºä¾‹1ï¼šç®€å•åŠ¨é‡å› å­
  ```python
  def calculate_momentum_10d():
      df = pd.read_hdf("daily_pv.h5", key="data").sort_index()
      
      # é‡å‘½å
      rename_map = {"$open": "open", "$close": "close", "$volume": "volume"}
      df = df.rename(columns=rename_map)
      
      # å› å­è®¡ç®—ï¼š10æ—¥æ”¶ç›Šç‡
      momentum = df["close"] / df["close"].groupby(level="instrument").shift(10) - 1
      
      # è¾“å‡º
      result_df = pd.DataFrame(index=df.index)
      result_df["momentum_10d"] = momentum.astype("float32")
      result_df.index.names = df.index.names
      result_df.to_hdf("result.h5", key="data", mode="w")
      return result_df
  ```
  
  ç¤ºä¾‹2ï¼šä½¿ç”¨ groupby+rolling
  ```python
  def calculate_volatility_20d():
      df = pd.read_hdf("daily_pv.h5", key="data").sort_index()
      
      # é‡å‘½å
      rename_map = {"$open": "open", "$close": "close", "$volume": "volume"}
      df = df.rename(columns=rename_map)
      
      # å› å­è®¡ç®—ï¼š20æ—¥æ³¢åŠ¨ç‡
      returns = df["close"] / df["close"].groupby(level="instrument").shift(1) - 1
      volatility = returns.groupby(level="instrument").rolling(window=20).std()
      volatility = volatility.reset_index(level=0, drop=True)  # å…³é”®ï¼æ¢å¤ç´¢å¼•
      
      # è¾“å‡º
      result_df = pd.DataFrame(index=df.index)
      result_df["volatility_20d"] = volatility.astype("float32")
      result_df.index.names = df.index.names
      result_df.to_hdf("result.h5", key="data", mode="w")
      return result_df
  ```
  
  ç¤ºä¾‹3ï¼šä½¿ç”¨ static_factors.parquet
  ```python
  def calculate_turnover_ratio():
      df = pd.read_hdf("daily_pv.h5", key="data").sort_index()
      
      # é‡å‘½å
      rename_map = {"$open": "open", "$close": "close", "$volume": "volume", "$amount": "amount"}
      df = df.rename(columns=rename_map)
      
      # è¯»å–é™æ€å› å­ï¼ˆåªè¯»å–éœ€è¦çš„åˆ—ï¼‰
      required_static_cols = ["db_turnover_rate", "db_circ_mv"]
      static_df = pd.read_parquet("static_factors.parquet", columns=required_static_cols).sort_index()
      
      # åˆå¹¶æ•°æ®
      df = df.join(static_df, how="left")
      
      # å› å­è®¡ç®—ï¼šæ¢æ‰‹ç‡
      turnover = df["db_turnover_rate"]
      
      # è¾“å‡º
      result_df = pd.DataFrame(index=df.index)
      result_df["turnover_ratio"] = turnover.astype("float32")
      result_df.index.names = df.index.names
      result_df.to_hdf("result.h5", key="data", mode="w")
      return result_df
  ```
  
  ç¤ºä¾‹4ï¼šå¤šåˆ— groupby+rolling
  ```python
  def calculate_price_volume_correlation():
      df = pd.read_hdf("daily_pv.h5", key="data").sort_index()
      
      # é‡å‘½å
      rename_map = {"$open": "open", "$close": "close", "$volume": "volume"}
      df = df.rename(columns=rename_map)
      
      # è®¡ç®—æ”¶ç›Šç‡
      returns = df["close"] / df["close"].groupby(level="instrument").shift(1) - 1
      volume_change = df["volume"] / df["volume"].groupby(level="instrument").shift(1) - 1
      
      # åˆå¹¶åˆ°ä¸€èµ·
      df["returns"] = returns
      df["volume_change"] = volume_change
      
      # å› å­è®¡ç®—ï¼šä»·é‡ç›¸å…³æ€§
      corr = df.groupby(level="instrument")[["returns", "volume_change"]].rolling(window=20).corr()
      # corr çš„ç´¢å¼•æ˜¯ (datetime, instrument, level_2)ï¼Œæå– returns å’Œ volume_change çš„ç›¸å…³æ€§
      corr = corr.reset_index(level=0, drop=True)
      corr = corr.xs("returns", level="level_2")["volume_change"]
      
      # è¾“å‡º
      result_df = pd.DataFrame(index=df.index)
      result_df["price_volume_corr"] = corr.astype("float32")
      result_df.index.names = df.index.names
      result_df.to_hdf("result.h5", key="data", mode="w")
      return result_df
  ```
```

### 3.5 prompts_language_spec.yamlï¼ˆè¯­è¨€è§„èŒƒï¼‰

```yaml
factor_coder_language_spec: |-
  ã€è¯­è¨€è§„èŒƒã€‘
  
  1. ä»£ç æ³¨é‡Šï¼šä½¿ç”¨ä¸­æ–‡
     ```python
     # è¯»å–æ•°æ®
     df = pd.read_hdf("daily_pv.h5", key="data").sort_index()
     
     # ç»Ÿä¸€é‡å‘½å
     rename_map = {"$open": "open", "$close": "close"}
     df = df.rename(columns=rename_map)
     
     # å› å­è®¡ç®—
     series = df["close"].groupby(level="instrument").rolling(10).mean()
     ```
  
  2. å˜é‡åï¼šä½¿ç”¨è‹±æ–‡ï¼ˆä¿æŒä»£ç å¯è¯»æ€§ï¼‰
     ```python
     # æ­£ç¡®
     close_price = df["close"]
     rolling_mean = series.rolling(10).mean()
     
     # é¿å…
     æ”¶ç›˜ä»· = df["close"]
     æ»šåŠ¨å‡å€¼ = series.rolling(10).mean()
     ```
  
  3. é”™è¯¯ä¿¡æ¯ï¼šä½¿ç”¨ä¸­æ–‡
     ```python
     if missing:
         raise ValueError(f"ç¼ºå°‘å¿…è¦åˆ—: {missing}. è¯·ä½¿ç”¨å¯ç”¨å­—æ®µé‡æ–°è®¾è®¡å› å­ã€‚")
     ```
  
  4. è¾“å‡ºè¯´æ˜ï¼šä½¿ç”¨ä¸­æ–‡
     ```python
     # åœ¨ä»£ç ä¸­æ·»åŠ ä¸­æ–‡è¯´æ˜æ³¨é‡Š
     # æœ¬å› å­è®¡ç®—10æ—¥åŠ¨é‡ï¼Œåæ˜ ä»·æ ¼è¶‹åŠ¿
     momentum = df["close"] / df["close"].groupby(level="instrument").shift(1) - 1
     ```
```

### 3.6 prompts_dataset_info.yamlï¼ˆæ•°æ®é›†ä¿¡æ¯ï¼‰

```yaml
factor_coder_dataset_info: |-
  ã€æ•°æ®é›†ä¿¡æ¯ã€‘
  
  æ•°æ®é›†ï¼šAIstock A-share (non-ST, non-delisted)
  è‚¡ç¥¨ä»£ç æ ¼å¼ï¼šQlib é£æ ¼ï¼ˆå¦‚ `000001.SZ`, `600000.SH`ï¼‰
  
  æ•°æ®æ–‡ä»¶ï¼š
    - daily_pv.h5ï¼šæ—¥çº¿ä»·é‡æ•°æ®ï¼Œç´¢å¼•ä¸º MultiIndex(datetime, instrument)
    - static_factors.parquetï¼šé™æ€å› å­ï¼ˆå¯é€‰ï¼‰ï¼ŒåŒ…å«ä¼°å€¼ã€å¸‚å€¼ã€æµåŠ¨æ€§ç­‰å­—æ®µ
  
  å¯ç”¨å­—æ®µï¼š
    - ä»·é‡å­—æ®µï¼šopen, high, low, close, volume, amount
    - é™æ€å­—æ®µï¼šdb_*ï¼ˆä¼°å€¼ã€å¸‚å€¼ç­‰ï¼‰ã€mf_*ï¼ˆèµ„é‡‘æµç­‰ï¼‰
    - æ³¨æ„ï¼šåªèƒ½ä½¿ç”¨ schema ä¸­åˆ—å‡ºçš„å­—æ®µï¼Œç¦æ­¢ç¼–é€ å­—æ®µå
  
  è¾“å‡ºè¦æ±‚ï¼š
    - å› å­å€¼ï¼šfloat32 ç±»å‹
    - ç´¢å¼•ï¼šMultiIndex(datetime, instrument)
    - æ–‡ä»¶ï¼šresult.h5
```

### 3.7 prompts.yamlï¼ˆä¸»æç¤ºè¯ - ç»„åˆç‰ˆæœ¬ï¼‰

```yaml
evaluator_code_feedback_v1_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  User will provide you the information of the factor.

  Your job is to check whether user's code is align with the factor and the scenario.
  The user will provide the source python code and the execution error message if execution failed.
  The user might provide you the ground truth code for you to provide the critic. You should not leak the ground truth code to the user in any form but you can use it to provide the critic.

  User has also compared the factor values calculated by the user's code and the ground truth code. The user will provide you some analyze result comparing two output. You may find some error in the code which caused the difference between the two output.

  If the ground truth code is provided, your critic should only consider checking whether the user's code is align with the ground truth code since the ground truth is definitely correct.
  If the ground truth code is not provided, your critic should consider checking whether the user's code is reasonable and correct.

  Notice that your critics are not for user to debug the code. They are sent to the coding agent to correct the code. So don't give any following items for the user to check like "Please check the code line XXX".

  You suggestion should not include any code, just some clear and short suggestions. Please point out very critical issues in your response, ignore non-important issues to avoid confusion. If no big issue found in the code, you can response "No critics found".
  
  You should provide the suggestion to each of your critic to help the user improve the code. Please response the critic in the following format. Here is an example structure for the output:
  critic 1: The critic message to critic 1
  critic 2: The critic message to critic 2

evaluator_code_feedback_v1_user: |-
  --------------Factor information:---------------
  {{ factor_information }}
  --------------Python code:---------------
  {{ code }}
  --------------Execution feedback:---------------
  {{ execution_feedback }}
  {% if value_feedback is not none %}
  --------------Factor value feedback:---------------
  {{ value_feedback }}
  {% endif %}
  {% if gt_code is not none %}
  --------------Ground truth Python code:---------------
  {{ gt_code }}
  {% endif %}

evolving_strategy_factor_implementation_v1_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  Your code is expected to align the scenario in any form which means The user needs to get the exact factor values with your code as expected.

  {% include "factor_coder.prompts_dataset_info:factor_coder_dataset_info" %}
  
  {% include "factor_coder.prompts_core_constraints:factor_coder_core_constraints" %}
  
  {% include "factor_coder.prompts_error_prevention:factor_coder_error_prevention" %}
  
  {% include "factor_coder.prompts_language_spec:factor_coder_language_spec" %}
  
  {% include "factor_coder.prompts_examples:factor_coder_examples" %}

  To help you write the correct code, the user might provide multiple information that helps you write the correct code:
  1. The user might provide you the correct code to similar factors. Your should learn from these code to write the correct code.
  2. The user might provide you the failed former code and the corresponding feedback to the code. The feedback contains to the execution, the code and the factor value. You should analyze the feedback and try to correct the latest code.
  3. The user might provide you the suggestion to the latest fail code and some similar fail to correct pairs. Each pair contains the fail code with similar error and the corresponding corrected version code. You should learn from these suggestion to write the correct code.
  
  Your must write your code based on your former latest attempt below which consists of your former code and code feedback, you should read the former attempt carefully and must not modify the right part of your former code.

  Notice that you should not add any other text before or after the json format.

  {% if queried_former_failed_knowledge|length != 0 %}
  --------------Your former latest attempt:---------------
  =====Code to the former implementation=====
  {{ queried_former_failed_knowledge[-1].implementation.all_codes }}
  =====Feedback to the former implementation=====
  {{ queried_former_failed_knowledge[-1].feedback }}
  {% endif %}

  Please response the code in the following json format. Here is an example structure for the JSON output:
  {
      "code": "The Python code as a string."
  }

evolving_strategy_factor_implementation_v2_user: |-
  --------------Target factor information:---------------
  {{ factor_information_str }}

  {% if queried_similar_error_knowledge|length != 0 %}
  {% if error_summary_critics is none %}
  Recall your last failure, your implementation met some errors.
  When doing other tasks, you met some similar errors but you finally solve them. Here are some examples:
  {% for error_content, similar_error_knowledge in queried_similar_error_knowledge %} 
  --------------Factor information to similar error ({{error_content}}):---------------
  {{ similar_error_knowledge[0].target_task.get_task_information() }}
  =====Code with similar error ({{error_content}}):=====
  {{ similar_error_knowledge[0].implementation.all_codes }}
  =====Success code to former code with similar error ({{error_content}}):=====
  {{ similar_error_knowledge[1].implementation.all_codes }}
  {% endfor %}
  {% else %}
  Recall your last failure, your implementation met some errors.
  After reviewing some similar errors and their solutions, here are some suggestions for you to correct your code:
  {{error_summary_critics}}
  {% endif %}
  {% endif %}
  {% if queried_similar_successful_knowledge|length != 0 %}
  Here are some success implements of similar component tasks, take them as references:
  --------------Correct code to similar factors:---------------
  {% for similar_successful_knowledge in queried_similar_successful_knowledge %}
  =====Factor {{loop.index}}:=====
  {{ similar_successful_knowledge.target_task.get_task_information() }}
  =====Code:=====
  {{ similar_successful_knowledge.implementation.all_codes }}
  {% endfor %}
  {% endif %}
  {% if latest_attempt_to_latest_successful_execution is not none %}
  You have tried to correct your former failed code but still met some errors. Here is the latest attempt to the latest successful execution, try not to get the same error to your new code:
  =====Your latest attempt=====
  {{ latest_attempt_to_latest_successful_execution.implementation.all_codes }}
  =====Feedback to your latest attempt=====
  {{ latest_attempt_to_latest_successful_execution.feedback }}
  {% endif %}

evolving_strategy_error_summary_v2_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  User is doing the following task: 
  {{factor_information_str}}

  You have written some code but it meets errors like the following:
  {{code_and_feedback}}

  The user has found some tasks that met similar errors, and their final correct solutions.
  Please refer to these similar errors and their solutions, provide some clear, short and accurate critics that might help you solve the issues in your code.

  You suggestion should not include any code, just some clear and short suggestions. Please point out very critical issues in your response, ignore non-important issues to avoid confusion. If no big issue found in the code, you can response "No critics found".

  [NOTE]
  1. When processing data, avoid time leakage.

  Please response the critic in the following format. Here is an example structure for the output:
  critic 1: The critic message to critic 1
  critic 2: The critic message to critic 2
  
evolving_strategy_error_summary_v2_user: |-
  {% if queried_similar_error_knowledge|length != 0 %}
  {% for error_content, similar_error_knowledge in queried_similar_error_knowledge %} 
  --------------Factor information to similar error ({{error_content}}):---------------
  {{ similar_error_knowledge[0].target_task.get_task_information() }}
  =====Code with similar error ({{error_content}}):=====
  {{ similar_error_knowledge[0].implementation.all_codes }}
  =====Success code to former code with similar error ({{error_content}}):=====
  {{ similar_error_knowledge[1].implementation.all_codes }}
  {% endfor %}
  {% endif %}


select_implementable_factor_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  Your job is to help the user select the easiest-to-implement factors. Some factors may be difficult to implement due to a lack of information or excessive complexity. The user will provide the number of factors you should pick and information about the factors, including their descriptions, formulas, and variable explanations.
  User will provide you the former attempt to implement the factor and the feedback to the implementation. You need to carefully review your previous attempts. Some factors have been repeatedly tried without success. You should consider discarding these factors.
  Please analyze the difficulties of the each factors and provide the reason and response the indices of selected implementable factor in the json format. Here is an example structure for the JSON output:
  {
      "Analysis": "Analyze the difficulties of the each factors and provide the reason why the factor can be implemented or not."
      "selected_factor": "The indices of selected factor index in the list, like [0, 2, 3].The length should be the number of factor left after filtering.",
  }

select_implementable_factor_user: |-
  Number of factor you should pick: {{ factor_num }}
  {% for factor_info in sub_tasks %} 
  =============Factor index:{{factor_info[0]}}:=============
  =====Factor name:=====
  {{ factor_info[1].factor_name }}
  =====Factor description:=====
  {{ factor_info[1].factor_description }}
  =====Factor formulation:=====
  {{ factor_info[1].factor_formulation }}
  {% if factor_info[2]|length != 0 %}
  --------------Your former attempt:---------------
  {% for former_attempt in factor_info[2] %}
  =====Code to attempt {{ loop.index }}=====
  {{ former_attempt.implementation.all_codes }}
  =====Feedback to attempt {{ loop.index }}=====
  {{ former_attempt.feedback }}
  {% endfor %}
  {% endif %}
  {% endfor %}

evaluator_output_format_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  User will provide you the format of the output. Please help to check whether the output is align with the format.
  Please respond in the JSON format. Here is an example structure for the JSON output:
  {
      "output_format_decision": True,
      "output_format_feedback": "The output format is correct."
  }


evaluator_final_decision_v1_system: |-
  User is trying to implement some factors in the following scenario:
  {{ scenario }}
  User has finished evaluation and got some feedback from the evaluator.
  The evaluator run the code and get the factor value dataframe and provide several feedback regarding user's code and code output. You should analyze the feedback and considering the scenario and factor description to give a final decision about the evaluation result. The final decision concludes whether the factor is implemented correctly and if not, detail feedback containing reason and suggestion if the final decision is False.

  The implementation final decision is considered in the following logic:
  1. If the value and the ground truth value are exactly the same under a small tolerance, the implementation is considered correct.
  2. If the value and the ground truth value have a high correlation on ic or rank ic, the implementation is considered correct.
  3. If no ground truth value is provided, the implementation is considered correct if the code executes successfully (assuming the data provided is correct). Any exceptions, including those actively raised, are considered faults of the code. Additionally, the code feedback must align with the scenario and factor description. The implementation cannot be considered correct if the code execution failed, no matter what the reason is.

  Please response the critic in the json format. Here is an example structure for the JSON output, please strictly follow the format:
  {
      "final_decision": True,
      "final_feedback": "The final feedback message",
  }

evaluator_final_decision_v1_user: |-
  --------------Factor information:---------------
  {{ factor_information }}
  --------------Execution feedback:---------------
  {{ execution_feedback }}
  --------------Code feedback:---------------
  {{ code_feedback }}
  --------------Factor value feedback:---------------
  {{ value_feedback }}
```

---

## å››ã€å¯¹æ¯”æ€»ç»“

### 4.1 æ”¹è¿›æ•ˆæœå¯¹æ¯”

| æ–¹é¢ | ç°æœ‰ç‰ˆæœ¬ | å»ºè®®ç‰ˆæœ¬ | æ”¹è¿›æ•ˆæœ |
|------|----------|----------|----------|
| **æ€»è¡Œæ•°** | 464è¡Œ | ä¸»æ–‡ä»¶~150è¡Œ + 5ä¸ªæ¨¡å—æ–‡ä»¶ | ä¸»æ–‡ä»¶å‡å°‘68% |
| **æ ¸å¿ƒçº¦æŸå¯è§æ€§** | åˆ†æ•£åœ¨140è¡Œä¸­ | é›†ä¸­åœ¨ç‹¬ç«‹æ–‡ä»¶ | æ˜¾è‘—æå‡ |
| **é”™è¯¯é¢„é˜²** | 2è¡Œè½»ææ·¡å†™ | 5ä¸ªè¯¦ç»†é”™è¯¯æ¡ˆä¾‹ | æ˜¾è‘—æå‡ |
| **ç¤ºä¾‹å®Œæ•´æ€§** | 1ä¸ªç®€å•ç¤ºä¾‹ | 4ä¸ªå®Œæ•´ç¤ºä¾‹ | æ˜¾è‘—æå‡ |
| **å†—ä½™å†…å®¹** | åŒ…å«æ¨¡å‹è®­ç»ƒã€ç­–ç•¥æ¼”è¿› | ç§»é™¤å†—ä½™å†…å®¹ | æ˜¾è‘—æå‡ |
| **è¯­è¨€ä¸€è‡´æ€§** | ä¸­è‹±æ–‡æ··ç”¨ | ç»Ÿä¸€è¯­è¨€è§„èŒƒ | æ˜¾è‘—æå‡ |
| **ç»´æŠ¤æ€§** | å•æ–‡ä»¶éš¾ä»¥ç»´æŠ¤ | æ¨¡å—åŒ–æ˜“äºç»´æŠ¤ | æ˜¾è‘—æå‡ |

### 4.2 é¢„æœŸæ•ˆæœ

æ ¹æ®ä¹‹å‰çš„é”™è¯¯åˆ†æï¼Œå®æ–½å»ºè®®ç‰ˆæœ¬åé¢„è®¡å¯ä»¥ï¼š

| æŒ‡æ ‡ | ç°æœ‰ç‰ˆæœ¬ | å»ºè®®ç‰ˆæœ¬ | æ”¹è¿›å¹…åº¦ |
|------|----------|----------|----------|
| **å¹³å‡codingè½®æ•°** | 6.2è½® | 3-4è½® | å‡å°‘35-48% |
| **éœ€è¦10è½®çš„ä»»åŠ¡æ¯”ä¾‹** | 43.5% | 15-20% | å‡å°‘54-65% |
| **groupby+rollingé”™è¯¯æ¬¡æ•°** | 100+æ¬¡ | é¢„è®¡<30æ¬¡ | å‡å°‘70%+ |
| **åˆ—åæ··æ·†é”™è¯¯æ¬¡æ•°** | 60+æ¬¡ | é¢„è®¡<20æ¬¡ | å‡å°‘67%+ |

### 4.3 å®æ–½å»ºè®®

**é˜¶æ®µ1ï¼šå¿«é€ŸéªŒè¯ï¼ˆ1-2å¤©ï¼‰**
1. åˆ›å»ºæ‹†åˆ†ç‰ˆæœ¬çš„æ–‡ä»¶ç»“æ„
2. åœ¨æµ‹è¯•ç¯å¢ƒä¸­éªŒè¯includeæœºåˆ¶æ˜¯å¦æ­£å¸¸å·¥ä½œ
3. å¯¹æ¯”ç°æœ‰ç‰ˆæœ¬å’Œæ‹†åˆ†ç‰ˆæœ¬çš„è¾“å‡ºç»“æœ

**é˜¶æ®µ2ï¼šé€æ­¥è¿ç§»ï¼ˆ3-5å¤©ï¼‰**
1. å…ˆè¿ç§»æ ¸å¿ƒçº¦æŸå’Œé”™è¯¯é¢„é˜²æ¨¡å—
2. éªŒè¯æ•ˆæœåï¼Œå†è¿ç§»ç¤ºä¾‹å’Œè¯­è¨€è§„èŒƒ
3. æœ€åæ¸…ç†å†—ä½™å†…å®¹

**é˜¶æ®µ3ï¼šå…¨é¢ä¼˜åŒ–ï¼ˆ1å‘¨ï¼‰**
1. æ ¹æ®å®é™…æ•ˆæœè°ƒæ•´å„æ¨¡å—å†…å®¹
2. æ·»åŠ æ›´å¤šé”™è¯¯æ¡ˆä¾‹å’Œç¤ºä¾‹
3. ä¼˜åŒ–è¯­è¨€è§„èŒƒå’Œçº¦æŸè¯´æ˜

---

## äº”ã€æ³¨æ„äº‹é¡¹

### 5.1 å…¼å®¹æ€§

- âœ… **å®Œå…¨å…¼å®¹**ï¼šæ‹†åˆ†åçš„æç¤ºè¯å¯¹ä¸»ç¨‹åºé€æ˜ï¼Œæ— éœ€ä¿®æ”¹ä¸»ç¨‹åºä»£ç 
- âœ… **å‘åå…¼å®¹**ï¼šå¯ä»¥ä¿ç•™ç°æœ‰æ–‡ä»¶ä½œä¸ºå¤‡ä»½
- âœ… **æ¸è¿›è¿ç§»**ï¼šå¯ä»¥é€æ­¥è¿ç§»ï¼Œä¸å½±å“ç°æœ‰åŠŸèƒ½

### 5.2 é£é™©è¯„ä¼°

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ |
|------|------|------|----------|
| includeæœºåˆ¶ä¸å·¥ä½œ | ä½ | é«˜ | å…ˆåœ¨æµ‹è¯•ç¯å¢ƒéªŒè¯ |
| æ¨¡å—åŠ è½½å¤±è´¥ | ä½ | ä¸­ | æ·»åŠ é”™è¯¯å¤„ç† |
| æ€§èƒ½ä¸‹é™ | ä½ | ä½ | å½±å“å¯å¿½ç•¥ |
| ç»´æŠ¤æˆæœ¬å¢åŠ  | ä¸­ | ä½ | æ¨¡å—åŒ–ååè€Œé™ä½ |

### 5.3 æµ‹è¯•å»ºè®®

1. **å•å…ƒæµ‹è¯•**ï¼šæµ‹è¯•æ¯ä¸ªæ¨¡å—æ˜¯å¦èƒ½æ­£ç¡®åŠ è½½
2. **é›†æˆæµ‹è¯•**ï¼šæµ‹è¯•includeæœºåˆ¶æ˜¯å¦æ­£å¸¸å·¥ä½œ
3. **æ•ˆæœæµ‹è¯•**ï¼šå¯¹æ¯”ç°æœ‰ç‰ˆæœ¬å’Œæ‹†åˆ†ç‰ˆæœ¬çš„codingæˆåŠŸç‡
4. **æ€§èƒ½æµ‹è¯•**ï¼šæµ‹è¯•åŠ è½½æ—¶é—´å’Œæ¸²æŸ“æ—¶é—´

---

**æŠ¥å‘Šç”Ÿæˆæ—¶é—´**: 2026-01-09  
**ç‰ˆæœ¬**: v1.0  
**ä¸‹ä¸€æ­¥**: æ ¹æ®ç”¨æˆ·åé¦ˆå†³å®šæ˜¯å¦å®æ–½æ‹†åˆ†æ–¹æ¡ˆ
