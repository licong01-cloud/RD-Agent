qlib_factor_interface_data_loading: |-
  【数据加载与字段名规范】
  - 主数据源为 `daily_pv.h5`，索引为 MultiIndex(`datetime`, `instrument`)，列名包括：`open`, `high`, `low`, `close`, `volume`, `amount`, `factor`。
  - 支持通过显式 join 引入 `static_factors.parquet` 中的指定字段，包括 **daily_basic (db_*)**、**moneyflow (mf_*)**、**bak_basic (bb_*)** 和 **cyq_perf (cp_*)** 四个数据集的字段。基于这些丰富的数据维度，LLM 可以设计出融合价格行为、资金流向、基本面特征、筹码分布的有效多因子策略。
  - **可选静态字段**：当前工作目录下可能存在 `static_factors.parquet`，其索引同样为 MultiIndex(`datetime`, `instrument`)，包含 `db_*`（每日基本面）、`mf_*`（资金流向）、`bb_*`（历史基本面）、`cp_*`（筹码分布）四类字段。各数据集的完整字段名、中文说明和单位请参考数据目录中的 `README.md` 文件（已在"source data"部分提供）。
    - **列名白名单（硬约束）**：只能使用 `static_factors_schema.csv` / `static_factors_schema.json` 或数据目录 `README.md` 中列出的字段名。严禁凭经验"编造/猜测"字段名（例如 `mf_net_inflow_1d`、`mf_large_buy_ratio` 等）。
    - 如果因子定义依赖这些字段（例如流通市值、流通股本、换手率、资金净流入等），**必须**显式读取并 join。为节省内存，**严禁全量加载**，必须通过 `columns` 参数仅读取必要的列：
      ```python
      # 必须：仅读取计算所需的列，以避免 OOM (static_factors.parquet 很大)
      required_static_cols = ["db_circ_mv", "mf_net_amt"] # 示例：按需替换为实际所需列名
      static_df = pd.read_parquet("static_factors.parquet", columns=required_static_cols).sort_index()
      
      # 注意：当前数据源的 instrument 已经是 Qlib 风格（600000.SH/000001.SZ），与 static_factors.parquet 完全对齐.
      # 直接执行 join 即可，无需进行格式转换.
      # 使用 join 将所需列合并到主 DataFrame 中
      df = df.sort_index().join(static_df, how="left")
      ```
    - **资金净流入等派生量（推荐做法）**：如果你需要"资金净流入/净流入占比/5日净流入"等字段，但 schema 中没有直接提供，请基于 `mf_*_buy_amt` / `mf_*_sell_amt` 组合自行派生（例如把 `sm/md/lg/elg` 四档买入金额相加减去卖出金额），并可进一步除以 `amount` 或 `db_circ_mv` 做归一化，再做 rolling 聚合。
    - 若 `static_factors.parquet` 不存在或缺少所需列，请直接报错并在下一轮改写因子定义（见下文约束），严禁用硬编码常数"拍脑袋补齐"。
